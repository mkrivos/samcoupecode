EOF:           EQU   26
EOL:           EQU   13

YES:           EQU   1
NO:            EQU   0

BPW:           EQU   2
LBPW:          EQU   1
SBPC:          EQU   1
COMPSIZE:      EQU   4

NAMESIZE:      EQU   14
NAMEMAX:       EQU   NAMESIZE+1

IDENT:         EQU   0
TYPE:          EQU   1
CLASS:         EQU   2
OFFSET:        EQU   3
INFOBYTE:      EQU   5  ; bit 0 if unsigned
                       ; bit 1 if function defined
                       ; bit 2 if used
                       ; bit 3 if struct item
                       ; bit 4 if autostatic
                       ; bit 5 if discardable
                       ; bit 6 if const
SIZEOF:        EQU   6
PARMS:         EQU   8  ; 0 for void, -1 for auto & variadic
IDENT2:        EQU   9
IDENT3:        EQU   10
IDENT4:        EQU   11
ONE:           EQU   12
EXTEND:        EQU   13
MENOSTR:       EQU   15
NAME:          EQU   17
SYMMAX:        EQU   NAME+NAMEMAX  ; 32
SYMAVG:        EQU   SYMMAX        ; 32


NUMLOCS:       EQU   50
STARTLOC:      EQU   symtab
ENDLOC:        EQU   NUMLOCS*SYMAVG+symtab
NUMGLBS:       EQU   800-50
STARTGLB:      EQU   ENDLOC
ENDGLB:        EQU   NUMGLBS-1*SYMMAX+ENDLOC
SYMTBSZ:       EQU   25600                    ;  (50+750)*32


VARIABLE:      EQU   1+128
ARRAY:         EQU   2+128
POINTER:       EQU   3+128
FUNCTION:      EQU   4+128
MENOVKA:       EQU   5+128
SYMBOL:        EQU   6+128
LABEL:         EQU   128


CVOID:         EQU   %0010       ; 2
CCHAR:         EQU   %0100      ; 4
CUCHAR:        EQU   %0101      ; 5
CINT:          EQU   %1000     ; 8
CUINT:         EQU   %1001     ; 9
CLONG:         EQU   %1100     ; 16
CULONG:        EQU   %1101     ; 17
CFLOAT:        EQU   %10000    ; 32
CDOUBLE:       EQU   %10001    ; 33
CSTRUCT:       EQU   %10000000 ; 128
CUNION:        EQU   %10000001 ; 129
CENUM:         EQU   %10000010 ; 130
MASK:          EQU   %11100

STATIC:        EQU   1     ; g
AUTOMATIC:     EQU   2     ; l
EXTERNAL:      EQU   3     ; g
AUTOEXT:       EQU   4     ; l
REGISTER:      EQU   5     ; l
TYPEDEF:       EQU   6


SWSIZ:         EQU   2*2
SWTABSZ:       EQU   35*SWSIZ


WQSIZ:         EQU   3*2
WQTABSZ:       EQU   WQSIZ*15
WQMAX:         EQU   wq+WQTABSZ-WQSIZ

WQSP:          EQU   0
WQLOOP:        EQU   2
WQEXIT:        EQU   4

LITABSZ:       EQU   1024
LITMAX:        EQU   LITABSZ-1

LINESIZE:      EQU   1024
LINEMAX:       EQU   LINESIZE-1


STAGESIZE:     EQU   800
STAGELIMIT:    EQU   STAGESIZE-1

MACNBR:        EQU   256
MACNSIZE:      EQU   NAMEMAX+3*MACNBR
MACEND:        EQU   macn+MACNSIZE
MACQSIZE:      EQU   MACNBR*8
MACMAX:        EQU   MACQSIZE-1

STEXPR:        EQU   7

To:            EQU   160
Tauto:         EQU   To
Tstatic:       EQU   01+To
Textern:       EQU   02+To
Tregister:     EQU   03+To
Ttypedef:      EQU   04+To
Tchar:         EQU   05+To
Tshort:        EQU   06+To
Tint:          EQU   07+To
Tlong:         EQU   08+To
Tunsigned:     EQU   09+To
Tfloat:        EQU   10+To
Tdouble:       EQU   11+To
Tenum:         EQU   12+To
Tstruct:       EQU   13+To
Tunion:        EQU   14+To
Tif:           EQU   15+To
Telse:         EQU   16+To
Twhile:        EQU   17+To
Tdo:           EQU   18+To
Tfor:          EQU   19+To
Tswitch:       EQU   20+To
Tcase:         EQU   21+To
Tdefault:      EQU   22+To
Tbreak:        EQU   23+To
Tcont:         EQU   24+To
Treturn:       EQU   25+To
Tgoto:         EQU   26+To
Tconst:        EQU   31+To

T#define:      EQU   49+To
T#undef:       EQU   50+To
T#include:     EQU   51+To
T#ifdef:       EQU   52+To
T#ifndef:      EQU   53+To
T#ifdeclared:  EQU   54+To
T#else:        EQU   55+To
T#endif:       EQU   56+To
T#error:       EQU   57+To
T#asm:         EQU   58+To
T#endasm:      EQU   T#asm+1
T#pragma:      EQU   60+To
Tsizeof:       EQU   61+To
Tvoid:         EQU   62+To
T#if:          EQU   63+To
Tsigned:       EQU   64+To
Tinterrupt:    EQU   65+To
T#elif:        EQU   66+To
Tdefined:      EQU   67+To
T#warning:     EQU   68+To

BUFER:         EQU   &80


               ORG   0
               DUMP  11,0

               JP    main+32768
               JP    zotav+32768

file.page:     DS    2
errors:        DS    1
liness:        DS    2
linesd:        DS    2
destiny:       DB    0
               DW    0
prefix:        DB    "C","C"
warnings:      NOP
optimize:      NOP
uchar:         DB    1
myorg:         DW    32768
codesp:        DW    &4A00
global:        DW    0
objects:       DW    STARTGLB
macros:        DW    macn
fast:          DB    0
smalljmp:      DB    0
startcode:     DB    1
skipline:      DB    0
makier:        DB    0
fname:         DM    "1234567890"
svflag:        NOP
smartcode:     DB    1

               DS    &38-$
               ORG   &38

               PUSH  HL
               LD    HL,0
               INC   HL
               LD    (&3A),HL
               POP   HL
               EI
               RET

zotav:         LD    (zot+1+32768),A
               IN    A,(250)
               SUB   COMPSIZE
               OUT   (250),A
               JP    $+3
               LD    SP,0
callsp:        EQU   $-2
               AND   31
               ADD   2
               OUT   (251),A
zot:           LD    A,0
               DB    195
loopv:         DW    0

               DS    &66-$

NMI:           NOP
               LD    A,201
               LD    (NMI),A
               LD    (errstack),SP
abort:         LD    A,1
               JP    volaj

errstack:      DW    0

               DS    &100-$
               ORG   &100

main:          IN    A,(250)
               LD    (lmpr+32768),A
               LD    (stc+32768),SP
               EI
               SUB   COMPSIZE
               OUT   (250),A
               JP    $+3

               LD    SP,&7FC0

               CALL  init.c

               LD    A,(svflag)
               AND   A
               CALL  NZ,addsvmac

               CALL  preprocess

               CALL  option

               CALL  header

               CALL  parse

               CALL  outside

               CALL  trailer

               CALL  fclose

               XOR   A
volaj:         LD    B,A
               IN    A,(250)
               AND   31
               OUT   (251),A

               JP    $+3+32768
               LD    A,(lmpr+32768)
               LD    SP,(stc+32768)
               OUT   (250),A
               LD    A,B
               RET

lmpr:          NOP
stc:           DW    0


init.c:        IN    A,(250)
               ADD   2
               AND   31
               OUT   (251),A
               LD    A,(file.page)
               LD    (source),A
               LD    A,(file.page+1)
               LD    (destiny),A

               LD    HL,swq
               LD    (swnext),HL

               LD    IY,&8000
               LD    (source+1),IY
               LD    (destiny+1),IY

               LD    HL,swq+SWTABSZ-SWSIZ
               LD    (swend),HL

               LD    HL,stage+STAGELIMIT
               LD    (stagelast),HL
               LD    HL,STARTGLB
               LD    (glbptr),HL

               XOR   A
               LD    L,A
               LD    H,A

               LD    (NMI),A
               LD    (incom),A
               LD    (swactive),A
               LD    (errors),A
               LD    (test2),A
               LD    (stagenext),HL
               LD    (iflevel),A
               LD    (discard2),A
               LD    (esc),A
               LD    (nxtlab),HL
               LD    (&3A),HL
               LD    (skiplevel),HL
               LD    (macptr),HL
               LD    (csp),HL
               LD    (global),HL
               LD    (errflag),A
               LD    (eof),A
               LD    (ncmp),A
               LD    (input),A
               LD    (makier),A
               INC   A
               LD    (ccode),A

               LD    A,&22
               LD    (quote),A
               LD    A,"0"
               LD    (quote+1),A

               LD    HL,wq
               LD    (wqptr),HL
               LD    A,EOF
               LD    (input2),A
               LD    HL,"@"
               LD    (hk+1),HL
               LD    HL,symtab
               LD    DE,symtab+1
               LD    BC,end2-symtab-1
               LD    (HL),0
               LDIR
               CALL  openfile

               LD    A,(smalljmp)
               AND   A
               LD    A,"p"
               JR    Z,$+4
               LD    A,"r"
               LD    (mov10+1),A
               LD    (mov121+1),A
               LD    (mov131+1),A
               LD    (mov141+1),A
               LD    HL,fname
               LD    DE,fname2
               LD    BC,8
               LDIR
               LD    HL,symbuf+2
               LD    (symbuf),HL
               LD    HL,extbuf+2
               LD    (extbuf),HL
               RET

option:        LD    A,T#pragma
               CALL  matches
               RET   NZ
               JP    dopragma

dovars:        LD    A,Tregister ; pre istotu
               CALL  matches
               LD    A,Tauto
               CALL  matches
               LD    A,Tinterrupt
               CALL  matches
               LD    (intf),A

               LD    A,Ttypedef
               CALL  matches
               LD    (tfl),A     ; zero if typedef
               JR    NZ,l0
               LD    A,TYPEDEF
               JP    dodeclare
l0:            LD    A,Textern
               CALL  matches
               JR    NZ,l1
               LD    A,EXTERNAL
               JP    dodeclare
l1:            LD    A,Tstatic
               CALL  matches
               LD    A,STATIC
               JP    dodeclare

parse:         LD    A,(eof)
               AND   A
               RET   NZ

               CALL  dovars
               JR    NZ,parse1
               LD    HL,tabcom
               CALL  dotok
               LD    A,H
               OR    L
               JR    Z,l5
               PUSH  HL
               CALL  preskoc
               POP   HL
               CALL  jphl
               JR    parse1
l5:            CALL  newfunc
parse1:        CALL  blanks
               JP    parse

dotok:         LD    A,(ch)
               LD    C,A
findtok:       LD    A,(HL)
               INC   HL
               AND   A
               JP    Z,nula
               CP    C
               JP    Z,hlhl
               INC   HL
               INC   HL
               JR    findtok

doendasm:      LD    A,1
               LD    (ccode),A
               JP    kill

dopragma:      LD    HL,msname
               CALL  symname
               LD    HL,msname
               LD    DE,pragma.1
               CALL  streq
               CP    4
               JR    NZ,r0
               LD    (argc),A
               RET
r0:            LD    HL,msname
               LD    DE,pragma.2
               CALL  streq
               CP    4
               JR    NZ,r1
               LD    A,(test2)
               XOR   1
               LD    (test2),A
               RET
r1:            LD    HL,msname
               LD    DE,pragma.3
               CALL  streq
               CP    6
               JR    NZ,r2
               CALL  volby
               RET
r2:            CALL  kill
               RET

volby:         LD    HL,atab
yr:            LD    A,(HL)
               AND   A
               JR    Z,xr
               PUSH  HL
               CALL  matches
               POP   HL
               INC   HL
               CALL  dehl
               INC   HL
               JR    NZ,yr
               EX    DE,HL
               JP    (HL)
xr:            CALL  error
               DM    "bad option switch"
               NOP
               CALL  kill
               RET

poo:           CALL  tog
               XOR   1
               LD    (optimize),A
volby2:        LD    A,","
               CALL  matches
               RET   NZ
               JR    volby

pf:            CALL  tog
               LD    (fast),A
               JR    volby2

pa:            CALL  value
               LD    (myorg),HL
               JR    volby2

ps:            CALL  value
               LD    (codesp),HL
               JR    volby2

pv:            CALL  tog
               LD    (svflag),A
               JR    volby2

pp:            CALL  tog
               LD    (startcode),A
               JR    volby2

pu:            CALL  tog
               LD    (uchar),A
               JR    volby2

pr:            CALL  value
               LD    A,H
               AND   A
               JR    Z,volby2
               LD    A,L
               AND   A
               JR    Z,volby2
               LD    (prefix),HL
               JR    volby2

pj:            CALL  tog
               LD    (smalljmp),A
               JR    volby2

pc:            CALL  tog
               LD    (skipline),A
               JR    volby2

px:            CALL  tog
               LD    (pushreg),A
               JR    volby2

pi:            CALL  tog
               CP    1
               SBC   1
               LD    (regflag),A
               JP    volby2

pee:           LD    A,1
               LD    (esc),A
               JP    volby2

pl:            CALL  tog
               LD    (smartcode),A
               JR    volby2

tog:           LD    A,"-"
               CALL  matches
               RET   Z
               LD    A,"+"
               CALL  matches
               LD    A,1
               RET   Z
               CALL  error
               DM    "'+' or '-' use only"
               NOP
               XOR   A
               RET


dumplits:      LD    (cald),A     ; A = size
               LD    HL,0             ; k
               LD    (mysk),HL
dumpli:        LD    HL,(litptr)
               LD    DE,(mysk)
               AND   A
               SBC   HL,DE
               RET   Z               ; RET if k=(litptr)

               LD    A,(cald)
               CALL  defstorage

               LD    B,11
dodefb:        PUSH  BC               ; j = pocet defb
               LD    A,(cald)

               LD    HL,(mysk)
               LD    DE,litq
               ADD   HL,DE           ; indexuj do zasobnika

               CP    1              ; HL odkial
               PUSH  AF
               CALL  NZ,hlhl        ; A  velkost
               POP   AF
               JR    NZ,$+5
               LD    L,(HL)
               LD    H,0

               JR    NZ,nout
               LD    A,L
               CP    " "
               JR    C,nout
               CP    128
               JR    NC,nout
               CP    34
               JR    Z,nout

               PUSH  HL
               LD    A,34
               CALL  outbyte
               POP   HL
               LD    A,L
               CALL  outbyte
               LD    A,34
               CALL  outbyte
               JR    zaou
nout:          CALL  outdec
zaou:          LD    HL,(mysk)
               LD    DE,(cald)
               LD    D,0
               ADD   HL,DE
               LD    (mysk),HL
               LD    DE,(litptr)
               AND   A
               SBC   HL,DE
               POP   BC
               JR    NC,konec
               DEC   B
               JR    Z,konec
               LD    A,","
               CALL  outbyte
               JR    dodefb
konec:         CALL  nl
               JP    dumpli

dumpzero:      LD    E,A     ; A = velkost
               LD    D,0
               EX    DE,HL
               CALL  CCUMUL           ; HL =pocet
dumpl1:        BIT   7,D
               RET   NZ      ; -1 nic
               LD    A,H
               OR    L
               RET   Z       ; 0 nic

               CALL  defspace
               RET   Z       ; bol nop
               CALL  outdec
               JP    nl

defspace:      DEC   HL
               LD    A,H
               OR    L
               JR    NZ,nonop
               LD    HL,nopt
               CALL  ol
               XOR   A
               RET
nonop:         DEC   HL
               LD    A,H
               OR    L
               JR    NZ,nonop2
               LD    A,2
               CALL  defstorage
               LD    HL,0
               XOR   A
               INC   A
               RET
nonop2:        PUSH  HL
               LD    A,3
               CALL  defstorage
               POP   HL
               INC   HL
               INC   HL
               XOR   A
               INC   A
               RET

outside:       LD    HL,ncmp
               LD    A,(ccode)
               XOR   1
               OR    (HL)
               LD    HL,iflevel
               OR    (HL)
               RET   Z

               CALL  error
               DM    "no closing #endasm or #endif"
               DB    0
               RET

fclose:        LD    A,(destiny) ; zatvor vystupny subor
               LD    (file.page+1),A
               INC   IY
               LD    (destiny+1),IY
               RET

openfile:      IN    A,(251)     ; otvor include
               EX    AF,AF'
               LD    A,(destiny)
               OUT   (251),A
               LD    (IY+0),0
               INC   IY
               EX    AF,AF'
               OUT   (251),A
               RET

doinclude:     CALL  blanks         ; !!!!!!!!
               LD    A,(input2)
               CP    EOF
               JR    Z,prvi
               CALL  error
               DM    "include nested"
               NOP
               JP    kill

prvi:          CALL  getname
               JR    NC,incerr

               LD    HL,filename
               PUSH  IY
               PUSH  IX
               CALL  fopen
               POP   IX
               POP   IY

               LD    (input2),A  ; EOF ak nieje OK
               CP    EOF
               JP    NZ,kill

incerr:        CALL  error
               DM    "open failure on include file"
               DB    0
               JP    kill

getname:       LD    A,34
               CALL  matches
               JR    Z,oknames
               LD    A,"<"
               CALL  matches
               JR    Z,oknames
               CALL  error
               DM    "bad include name"
               NOP
               SCF
               CCF            ; nc = err
               RET

oknames:       LD    B,10
               LD    HL,filename
               LD    DE,(lptr)
get1:          LD    A,(DE)
               CP    34
               JR    Z,get2
               CP    ">"
               JR    Z,get2
               LD    (HL),A
               INC   HL
               INC   DE
               DEC   B
               JR    NZ,get1

get2:          DEC   B
               SCF
               RET   M
               LD    (HL)," "
               INC   HL
               JR    get2

dodeclare:     LD    B,A             ; vola sa z reg. A
               PUSH  BC              ; = STATIC or EXTERN
               XOR   A               ; (static, extern)
               LD    (unsigned),A
               CALL  settype         ; A=type or NULL
               POP   BC
               RET   Z               ; neuspel
               CALL  declglb         ; A & B
               JP    jedna           ; vracia tiez reg. A

dotype:        CALL  blanks         ; vracia -1 : 0 podla
               LD    HL,(lptr)      ; to synonymum
               PUSH  HL
               LD    HL,ssname
               PUSH  HL
               CALL  symname
               POP   HL
               JR    NC,v2
               CALL  findglb
               JR    Z,v2
               INC   HL
               INC   HL
               LD    A,(HL)
               CP    TYPEDEF
               JR    NZ,v2
               DEC   HL
               DEC   HL
               LD    (synonym),HL
               POP   HL
               LD    A,&40
               RET
v2:            POP   HL
               CALL  bump2   ; obnovi lptr
               JP    nula

unava:         CALL  warning
               DM    "not implemented - int used"
               NOP
               CALL  preskoc
               LD    A,CINT
               JR    mastyp  ; float, long ... ako int

settype:       LD    HL,0
               LD    (synonym),HL
               LD    (menovka),HL
               LD    (extensia),HL
               XOR   A
               LD    (constf),A
               LD    (unsigned),A
               CALL  clstru2

               LD    A,Tconst
               CALL  matches
               JR    NZ,$+6
               INC   A
               LD    (constf),A

               LD    A,Tunsigned     ; implicint unsign
               CALL  matches
               JR    NZ,dodec21
               INC   A
               LD    (unsigned),A
               JR    dodec2

dodec21:       LD    A,Tsigned       ; implicint signed
               CALL  matches
               JR    NZ,dodec2
               LD    A,2
               LD    (unsigned),A
dodec2:        LD    A,(ch)
               CP    Tlong
               JR    Z,unava
               CP    Tdouble
               JR    Z,unava
               CP    Tfloat
               JR    Z,unava

               LD    A,Tstruct
               CALL  matches
               JR    NZ,dodecl
               LD    A,CSTRUCT
mastyp:        AND   A           ; nastav NZ a vrat typ
               RET

dodecl:        LD    A,Tunion
               CALL  matches
               LD    A,CUNION
               JR    Z,mastyp

               LD    A,Tenum
               CALL  matches
               LD    A,CENUM
               JR    Z,mastyp

               LD    A,Tshort
               CALL  matches
               JP    Z,dodec9     ; posud aj znaminko

               LD    A,Tvoid
               CALL  matches
               LD    A,CVOID
               JR    Z,mastyp

               LD    A,Tchar
               CALL  matches
               JR    NZ,dodec1
               LD    B,CCHAR
               LD    HL,unsigned
               LD    A,(HL)
               AND   A
               JR    Z,$+7
dosign:        AND   1        ; explicint
               OR    B
               JR    mastyp
               LD    A,(uchar) ; implicint
               OR    B
               JR    mastyp

dodec1:        CALL  match
               DB    Tint
               LD    HL,unsigned
               LD    A,(HL)
               LD    B,CINT
               JR    Z,dosign
               AND   3               ; samotne unsigned
               JR    Z,dot6
               CP    2
               LD    A,CUINT
               JR    NZ,mastyp
               LD    A,CINT          ; samotne signed
               JR    mastyp

dot6:          CALL  dotype
               AND   A
               JR    Z,mastyp

expdef:        PUSH  IX            ; typedef
               LD    IX,(synonym)
               LD    A,(IX+IDENT)
               LD    (jj),A
               LD    A,(IX+IDENT2)
               LD    (jj+1),A
               LD    A,(IX+IDENT3)
               LD    (stru2+15),A
               LD    L,(IX+SIZEOF)
               LD    H,(IX+SIZEOF+1)
               LD    (stru2+12),HL
               LD    A,(IX+ONE)
               LD    (one),A
               LD    A,(IX+TYPE)  ; zober si typ
               LD    (dtype),A
               LD    L,(IX+MENOSTR)
               LD    H,(IX+MENOSTR+1)
               LD    (menovka),HL
               POP   IX           ; u struktur set menovka
               JP    mastyp

dodec9:        CALL  match
               DB    Tint
               LD    A,CINT
               JP    Z,mastyp
               XOR   A
               LD    A,2
               LD    (unsigned),A
               JP    dodec1+4

setjj:         PUSH  AF       ; IDENT -> IDENT2 -> IDENT3
               LD    A,(jj+1)
               LD    (stru2+15),A
               LD    A,(jj)
               LD    (jj+1),A
               POP   AF
               LD    (jj),A
               RET

anonym:        LD    A,"_"
               LD    (ssname),A
hk:            LD    HL,"@"
               INC   HL
               LD    (hk+1),HL
               LD    (ssname+1),HL
               RET

dostruct:      LD    A,(synonym+1)
               AND   A
               JP    NZ,named      ; via typedef
               LD    HL,ssname     ; spracovanie strukturovanych
               CALL  symname       ; premennych struct, enum ..
               CALL  NC,anonym
               CALL  clstru2
               LD    HL,ssname
               CALL  findglb
               LD    (menovka),HL  ; hl=cptr
               JP    NZ,named      ; ide o definovanie

               LD    HL,ssname
               LD    (stru2),HL
               LD    HL,MENOVKA
               LD    (stru2+2),HL
               LD    A,(dtype3)
               LD    (stru2+4),A    ; type = ENUM, STRUCT, UNION
               LD    HL,glbptr
               LD    (stru2+8),HL
               LD    HL,(dclas)
               LD    H,0
               LD    (stru2+10),HL

           ; uloz menovku predbezne

               CALL  addsym
               LD    (menovka),HL
               LD    A,"{"
               CALL  needtoken
               XOR   A
               LD    (parms),A
               LD    HL,0
               LD    (some3),HL      ; posun pre polozky (stru2+6
               LD    (some4),HL     ; sizeof =0
               LD    HL,msname
               LD    (stru2),HL     ; name
               LD    HL,SYMBOL
               LD    (stru2+2),HL   ; ident = SYMBOL
               LD    A,(dtype3)
               CP    CENUM
               JP    Z,doenum       ; enum urob oddelene

nexitem:       CALL  dositem        ; hl=sizeof
               JR    Z,serr
               CALL  aktualizuj     ; hl a de
               CALL  dosymbol2      ; type, ident is set
               LD    A,","
               CALL  matches
               JR    NZ,cezcoma
               CALL  dositemx
               JR    nexitem+3

cezcoma:       LD    A,":"
               CALL  matches
               JR    NZ,nobitf
               CALL  error
               DM    "bitfields isn't implemented"
               NOP
nobitf:        CALL  ns
               LD    A,"}"
               CALL  matches
               JR    NZ,nexitem

serr:          LD    HL,(menovka)   ; zaznac este velkost
               LD    DE,SIZEOF
               ADD   HL,DE
               LD    DE,(some4)
               LD    (HL),E
               INC   HL
               INC   HL
               INC   HL
               INC   HL
               INC   HL
               INC   HL
               LD    (HL),E         ; set ONE
               INC   D
               DEC   D
               JR    Z,ht
               CALL  error
               DM    "too big struct or union"
               NOP
ht:            LD    HL,(menovka)
               PUSH  HL
               LD    (synonym),HL
               CALL  clstru2
               LD    HL,0
               LD    (synonym),HL
               POP   HL
               LD    (menovka),HL

named:         LD    A,(dtype3)
               CP    CENUM
               RET   NZ
               LD    A,CINT
               LD    (dtype3),A
               RET

doenum:        LD    HL,msname
               CALL  symname
               CALL  NC,illname
               LD    A,"="
               CALL  matches
               LD    HL,(some3)
               JR    NZ,implicit2
               LD    HL,some4
               CALL  constexpr
               LD    HL,(some4)
implicit2:     PUSH  HL
               CALL  dosymbol
               POP   HL
               INC   HL
               LD    (some3),HL
               DEC   HL
               CALL  doequ
               LD    A,","
               CALL  matches
               JR    Z,doenum
               LD    A,"}"
               CALL  needtoken
               JR    named

doequ:         PUSH  HL
               LD    HL,msname
               CALL  ot
               LD    A,":"
               CALL  outbyte
               LD    HL,equs
               CALL  ot
               POP   HL
               CALL  outdec
               JP    nl

syntax:        CALL  error
               DM    "struct syntax error"
               NOP
               XOR   A
               RET

dositem:       LD    HL,(menovka)
               PUSH  HL
               CALL  settype
               POP   HL
               LD    (menovka),HL ; save menovky docasne
               JR    Z,syntax
               LD    (dtype),A    ; INT CHAR STRUCT UNION

dositemx:      LD    HL,1
               LD    (kk),HL
               LD    A,(dtype)
               BIT   7,A
               JR    Z,nost3

               LD    HL,(synonym)  ; struct in struct
               INC   H
               DEC   H
               JR    NZ,oksts      ; via typedef
               LD    HL,dsname
               PUSH  HL
               CALL  symname
               CALL  NC,illname
               LD    HL,ssname
               LD    DE,dsname
               CALL  streq
               POP   HL
               LD    (se),A
               JR    NZ,oksts   ; struct in struct itself

               CALL  findglb    ; najdi struct MENOVKU
               JR    NZ,oksts
               CALL  error
               DM    "undefined struct or union"
               NOP
               JP    abort

oksts:         LD    DE,SIZEOF
               ADD   HL,DE
               CALL  hlhl
               LD    (ssize),HL

nost3:         CALL  ispoints
               LD    A,"("
               CALL  matches
               CALL  ispoints
               CALL  ispoints     ; kk=0 , double point **

comde_:        LD    HL,msname
               CALL  symname
               CALL  NC,illname     ; zly nazov
               DB    62
se:            NOP
               AND   A
               LD    A,(jj)
               JR    Z,se1
               SUB   VARIABLE
               JR    NZ,se1
               LD    (se),A
               CALL  error
               DM    "struct or union in itself"
               NOP
               JP    abort

se1:           XOR   A
               LD    (se),A
               LD    A,")"
               CALL  matches

               LD    A,"("         ; mozne su len point to fnc
               CALL  matches
               JR    NZ,za_        ;nie fnc

               LD    A,FUNCTION
               CALL  setjj         ; fnc cause
               CALL  spocitaj

za_:           LD    HL,msname
               CALL  findglb        ; discard
               CALL  NZ,multidef
               LD    A,"["
               CALL  matches
               JR    NZ,po_

               CALL  needsub        ; ide o pole
               LD    (kk),HL        ; set dimension
               LD    A,(parms)
               LD    (stru2+14),A
               CP    2
               JR    C,bezdi_
               ADD   A
               LD    C,A
               LD    B,0
               LD    HL,dimenzie
               CALL  toextbuf
               LD    (extensia),HL
bezdi_:        LD    A,(jj)
               CP    FUNCTION       ; pokial ide stale o fnc
               LD    A,POINTER      ; urob stoho pointer
               CALL  Z,setjj
               LD    A,ARRAY        ; pole ukazatelov na fcie
               CALL  setjj          ; ident=array
               JR    poss_

po_:           LD    A,(jj)
               CP    FUNCTION       ; pokial ide stale o fnc
               LD    A,POINTER      ; urob stoho pointer
               CALL  Z,setjj

poss_:         LD    A,(jj+1)
               CP    POINTER
               JR    Z,doubles4
               LD    A,(jj)
               CP    POINTER
               JR    Z,doubles4
               LD    A,(dtype)
               BIT   7,A
               DB    1
ssize:         DW    0
               JR    NZ,doubles4+4
               LD    C,1
               AND   MASK
               CP    CCHAR
               JR    Z,doubles4+2
doubles4:      LD    C,2         ; velkost objektu
               LD    B,0
               PUSH  BC
               LD    HL,(jj)
               LD    (stru2+2),HL   ; nastav dtype a ident
               LD    HL,(dtype)
               LD    (stru2+4),HL
               POP   HL          ; vrat velkost
               LD    DE,(kk)
               CALL  CCUMUL
               INC   L
               DEC   L           ; set NZ
               RET

aktualizuj:    PUSH  HL
               LD    A,(dtype3)
               CP    CUNION
               LD    DE,(some4)
               JR    Z,nooff
               ADD   HL,DE
               LD    (some4),HL  ; offset je zaroven velkost
               EX    DE,HL      ; hl=offset
               POP   DE         ; vystup zo sizeof
               RET
nooff:         AND   A
               SBC   HL,DE
               JR    C,mensia
               ADD   HL,DE
               LD    (some4),HL
mensia:        LD    HL,0       ; UNION offset je NULL
               POP   DE
               RET

dosymbol2:     LD    (stru2+12),DE ; de = sizeof prvku
               LD    A,8
               LD    (unsigned),A  ; struct/union item
dosymbol:      LD    (stru2+6),HL  ; offset oznacuje posun
               CALL  setone
               LD    HL,glbptr
               LD    (stru2+8),HL
               LD    HL,msname
               LD    (stru2),HL
               LD    HL,STATIC
               LD    (stru2+10),HL
               CALL  addsym
               RET

ispoints:      LD    A,"*"
               CALL  matches
               LD    A,POINTER
               CALL  Z,setjj
               RET

clstru2:       LD    HL,stru2
               LD    B,18
               LD    (HL),0
               INC   HL
               DJNZ  $-3
               LD    A,(synonym+1)
               AND   A
               JP    NZ,expdef
               LD    HL,VARIABLE
               LD    (jj),HL
               RET

declares:      LD    (dtype3),A   ; A, B
               LD    C,A
               LD    A,B
               LD    (dclas),A
               BIT   7,C          ; urob strukturu
               CALL  NZ,dostruct
               RET

declglb:       CALL  declares     ; A, B
declop:        CALL  endst
               JP    NZ,ns
               CALL  clstru2
               LD    A,(dtype3) ; kvoli fnc pointers
               LD    (dtype),A
               XOR   A
               LD    (unsigned),A  ; undefined ,znmienko v ident
               LD    HL,0
               LD    (kk),HL
               LD    (extensia),HL
               CALL  ispoints
               LD    A,"("
               CALL  matches
               CALL  ispoints
               JR    NZ,nopoi
               CALL  ispoints     ; kk=0 , double point **
               JR    comdec

nopoi:         LD    A,(jj)
               CP    POINTER
               JR    Z,comdec     ; hviezdicka
                                 ; jj=VARIABLE
               LD    A,1          ; dimenzia 1
               LD    (kk),A

comdec:        LD    HL,ssname
               CALL  symname
               PUSH  AF
               CALL  NC,illname     ; zly nazov
               POP   AF
               CP    2
               CALL  C,shname      ; kratky !!!
               XOR   A
               LD    (fpf),A
               LD    A,")"
               CALL  matches
               JR    NZ,fnctopo

               LD    A,POINTER
               LD    (fpf),A       ; POJDE O POITRE
fnctopo:       LD    A,"("
               CALL  matches
               JR    NZ,zar        ;nie fnc

               LD    A,FUNCTION
               CALL  setjj         ; fnc cause
               DB    62
fpf:           NOP
               AND   A
               JP    Z,definuj     ; pointre na fnc
               CALL  spocitaj
               LD    A,(parms)
               LD    (stru2+14),A

zar:           LD    HL,ssname      ; premenne, pointre,polia
               CALL  findglb
               JR    Z,nomul

               INC   HL
               INC   HL
               LD    A,(HL)
               CP    EXTERNAL
               JR    Z,nomul        ; ak uz je ako extern OK
               LD    A,(dclas)
               CP    EXTERNAL       ; teraz ako extern OK
               CALL  NZ,multidef    ; uz definovany  error

nomul:         LD    A,"["
               CALL  matches
               JR    NZ,pox

               CALL  needsub        ; ide o pole
               LD    (kk),HL        ; set dimension
               LD    A,(parms)
               LD    (stru2+14),A
               CP    2
               JR    C,bezdim
               ADD   A
               LD    C,A
               LD    B,0
               LD    HL,dimenzie
               CALL  toextbuf
               LD    (extensia),HL
bezdim:        LD    A,(jj)
               CP    FUNCTION       ; pokial ide stale o fnc
               LD    A,POINTER      ; urob stoho pointer
               CALL  Z,setjj
               LD    A,ARRAY        ; pole ukazatelov na fcie
               CALL  setjj          ; ident=array
               JR    possc

pox:           LD    A,(jj)
               CP    FUNCTION       ; pokial ide stale o fnc
               LD    A,POINTER      ; urob stoho pointer
               CALL  Z,setjj
possc:         LD    A,(dclas)      ; pokial je objekt externy
               CP    STATIC         ; nealokuje sa ziadna pamet
               JR    NZ,possc2
               LD    A,(jj)         ; ani fnc nealokuje nic
               CP    FUNCTION
               JR    Z,possc2

               LD    A,(jj+1)
               CP    POINTER
               JR    Z,doubles2
               LD    A,(dtype)
               BIT   7,A
               PUSH  AF
               CALL  NZ,getstrsize  ; velkost struct do BC
               POP   AF
               JR    NZ,doubles2+4
               LD    C,1
               AND   MASK
               CP    CCHAR
               JR    Z,doubles2+2
doubles2:      LD    C,2         ; velkost objektu
               LD    B,0
               LD    DE,(jj)     ; (pointer, variable ...)
               LD    HL,(kk)     ; dimenzia
               CALL  initials
               LD    A,L
               LD    (jj),A
               LD    A,2         ; objekt bol aj definovany
               LD    (unsigned),A

possc2:        LD    A,(dtype)   ; kontrola void typu
               CP    CVOID
               JR    NZ,novoid
               LD    A,(jj)
               CP    POINTER
               JR    Z,novoid
               CP    FUNCTION
               JR    Z,novoid
               CALL  warning
               DM    "void must be FUNCTION or POINTER"
               NOP
               LD    A,CINT      ; explicintne int
               LD    (dtype),A

novoid:        CALL  setsize       ; set offset
               LD    (stru2+12),HL
               LD    HL,ssname
               LD    (stru2),HL
               LD    HL,(jj)
               LD    (stru2+2),HL
               LD    HL,(dtype)
               LD    (stru2+4),HL
               LD    HL,glbptr
               LD    (stru2+8),HL
               LD    HL,(dclas)
               LD    (stru2+10),HL
               LD    A,(static)
               CP    STATIC
               JR    NZ,noaut
               LD    HL,unsigned  ; do autostatic
               SET   4,(HL)
               LD    HL,(autolab) ; label for auto
               LD    (stru2+6),HL
noaut:         CALL  setone
               CALL  addsym
               LD    A,","
               CALL  matches   ; viac ?
               JP    Z,declop
               JP    ns

setone:        LD    A,(dtype)
               BIT   7,A
               JR    Z,ins9
               CALL  getstrsize
               LD    A,C
ins0:          LD    (one),A  ;0:1:2:other
               RET
ins9:          AND   MASK+2
               CP    CVOID
               LD    C,0
               JR    Z,ins0-1
               CP    CCHAR
               LD    A,1
               JR    Z,ins0
               INC   A
               JR    ins0

setsize:       LD    A,(jj)
               LD    HL,0
               CP    FUNCTION
               RET   Z
               LD    A,(jj+1)
               CP    FUNCTION
               RET   Z
               LD    C,0
               CP    POINTER
               JR    NZ,$+4    ; pole pointrov
               LD    C,2
               CP    ARRAY
               LD    DE,1
               JR    NZ,rt
               LD    DE,(kk)
               INC   C
               DEC   C
               JR    Z,rt
               PUSH  DE
               JR    rt2
rt:            LD    A,(dtype)
               LD    B,0
               PUSH  DE
               CALL  size2
rt2:           LD    L,C
               LD    H,B
               POP   DE
               CALL  CCUMUL
               RET            ; HL = sizeof

size2:         LD    C,A
               LD    A,(jj+1)
               CP    POINTER
               LD    A,C
               LD    C,2
               RET   Z
size:          CP    CCHAR      ;Z = b sizeof
               LD    C,1        ;NZ= b=0
               RET   Z
               CP    CUCHAR
               RET   Z
               INC   C         ; char =1
               CP    CINT      ; A=int,char,void a fnc a pointer
               RET   Z
               CP    CUINT     ; int, uns, point = 2
               RET   Z
               LD    C,0       ; void =0
               CP    CVOID
               RET   Z
               CP    CLONG
               LD    C,4
               RET   Z
               CP    CULONG
               RET   Z
               CP    CFLOAT
               RET   Z
               CP    CDOUBLE
               RET   Z
               BIT   7,A
               JR    Z,nost     ; struct
getstrsize:    LD    HL,(menovka)
               LD    DE,SIZEOF
               ADD   HL,DE
               LD    C,(HL)
               INC   HL
               LD    B,(HL)
               RET

nost:          CP    FUNCTION
               RET   NZ
               PUSH  AF
               CALL  warning
               DM    "can't sizeof func"
               NOP
               POP   AF
               LD    B,0       ;fnc = -1
               RET

toextbuf:      LD    DE,(extbuf)
               PUSH  DE
               LDIR
               POP   HL
               LD    (extbuf),DE
               RET

hlhl:          LD    A,(HL)    ; get hl from (hl)
               INC   HL
               LD    H,(HL)
               LD    L,A
               RET

dehl:          LD    E,(HL)
               INC   HL
               LD    D,(HL)
               RET

hlde:          LD    (HL),E
               INC   HL
               LD    (HL),D
               RET

spocitaj:      XOR   A
               LD    (parms),A
               LD    A,")"
               CALL  matches
               RET   Z
               LD    A,Tvoid
               CALL  matches
               JR    Z,paren2
               CALL  elipsis
               JR    Z,paren2

whil50:        CALL  bumptype  ; int ...
               CALL  match
               DB    "*"
               CALL  match
               DB    "&"
               LD    HL,dsname
               CALL  symname
               CALL  NC,illname
               LD    HL,parms
               INC   (HL)
               LD    A,","
               CALL  matches
               JR    Z,whil50
paren2:        LD    A,")"
               JP    needtoken

elipsis:       LD    A,"."
               CALL  matches
               RET   NZ
               LD    A,-1      ; variadic fnc
               LD    (parms),A
               CALL  match
               DB    "."
               CALL  match
               DB    "."
               RET   Z
               CALL  error
               DM    "'.' expected after '..'"
               NOP
               XOR   A
               RET

bumptype:      CALL  blanks
               LD    A,(ch)
               CP    Tchar
               RET   C
               CP    Tunion+1
               RET   NC
               JP    preskoc ; preskoc char ... union

declloc:       LD    B,AUTOMATIC       ; vola sa z A
               CALL  declares

               LD    A,(swactive)      ; char, int struct
               AND   A                 ; bezpecne ide o AUTO
               JR    Z,oksw
               CALL  error
               DM    "not allowed in switch"
               DB    0
oksw:          LD    A,(noloc)
               AND   A
               JR    Z,oksw1
               CALL  error
               DM    "not allowed with goto"
               DB    0
oksw1:         LD    A,(declared+1)
               AND   A
               JP    P,okswl
               CALL  error
               DM    "must declare first in block"
               DB    0

okswl:         CALL  endst
               RET   NZ
               CALL  clstru2
               LD    A,(dtype3)
               LD    (dtype),A
               CALL  ispoints
               LD    A,"("
               CALL  matches
               CALL  ispoints
               CALL  ispoints
               LD    HL,ssname
               CALL  symname
               CALL  NC,illname
               LD    A,"="
               CALL  matches
               JR    NZ,uninit
               CALL  error
               DM    "can't initialize"
               NOP
               JP    abort
uninit:        LD    HL,BPW
               LD    (kk),HL
               XOR   A
               LD    (fpf),A
               LD    A,")"
               CALL  matches
               JR    NZ,fnctop1
               LD    A,POINTER
               LD    (fpf),A       ; POJDE O POITRE
fnctop1:       LD    A,"("
               CALL  matches
               JR    NZ,zaro       ;nie fnc

               LD    A,FUNCTION
               CALL  setjj         ; fnc cause
               CALL  spocitaj       ; klasicky prototyp
               LD    A,(parms)
               LD    (stru2+14),A   ; pocet parametrov bude parms
               LD    A,(fpf)
               AND   A
               JP    Z,posscy
               LD    HL,(jj)         ; nealokuj
               LD    A,L
               LD    L,H
               LD    H,A             ; vymen ptr & fnc
               LD    (jj),HL

zaro:          CALL  match
               DB    "["
               JR    NZ,nepole

               CALL  needsub
               LD    (kk),HL
               LD    A,H
               OR    L
               JR    Z,bezs
               LD    A,(parms)
               LD    (stru2+14),A
               CP    2
               JR    C,mx
               ADD   A
               LD    C,A
               LD    B,0
               LD    HL,dimenzie
               CALL  toextbuf
               LD    (extensia),HL
mx:            LD    A,ARRAY
               CALL  setjj
               LD    A,(jj+1)
               CP    POINTER
               JR    Z,doubles
               LD    A,(dtype)
               BIT   7,A
               JR    NZ,m4
               AND   MASK
               CP    CCHAR
               JR    Z,zaels
doubles:       LD    HL,(kk)      ;int pole -> dim*2
               ADD   HL,HL        ; pre struktury * sizeof
               LD    (kk),HL
               JR    zaels

m4:            CALL  getstrsize
               LD    E,C
               LD    D,B
               LD    HL,(kk)
               CALL  CCMUL
               LD    (kk),HL
               JR    zaels

bezs:          LD    A,POINTER     ;pole[] -> POINTER
               CALL  setjj
               LD    HL,BPW
               LD    (kk),HL
               JR    zaels

nepole:        LD    A,(jj)
               CP    POINTER
               JR    Z,zaels
               LD    A,(dtype)
               BIT   7,A
               JR    Z,my
               CALL  getstrsize
               LD    (kk),BC
               JR    zaels
my:            AND   MASK
               CP    CCHAR
               JR    NZ,zaels
               LD    A,(jj)
               CP    VARIABLE
               JR    NZ,zaels
               LD    HL,SBPC
               LD    (kk),HL    ; 1

zaels:         LD    HL,(declared)
               LD    DE,(kk)
               ADD   HL,DE
               LD    (declared),HL
               LD    A,2
               LD    (unsigned),A

posscy:        LD    A,(register)    ; vstup bez alokacie
               AND   A
               JR    Z,nebolr
               LD    A,(jj)
               CP    ARRAY
               JR    Z,nebolr
               CP    POINTER
               JR    Z,neb
               LD    A,(dtype)
               AND   MASK
               JR    Z,nebolr
neb:           LD    A,(usereg)
               CP    2               ; dve registrove mozne
               JR    NC,nebolr
               INC   A               ; urob registrovu premennu
               LD    (usereg),A
               LD    DE,(kk)
               LD    HL,(declared)
               AND   A
               SBC   HL,DE
               LD    (declared),HL   ; register nealokuje pamet
               LD    HL,REGISTER
               LD    (stru2+14),A    ; PARMS = 0 pre ix
               JR    nebolr+3        ;       = 1 pre iy

nebolr:        LD    HL,AUTOMATIC
               LD    (stru2+10),HL
               LD    HL,(kk)         ; !!!!!!
               LD    (stru2+12),HL
               LD    HL,ssname
               LD    (stru2),HL
               LD    HL,(jj)
               LD    (stru2+2),HL
               LD    HL,(dtype)
               LD    (stru2+4),HL
               LD    HL,(csp)
               LD    DE,(declared)
               AND   A
               SBC   HL,DE
               LD    (stru2+6),HL
               LD    HL,locptr
               LD    (stru2+8),HL
               CALL  setone
               CALL  addsym
               CALL  match
               DB    ","
               JP    Z,okswl
               RET

initials:      LD    (dsize),BC   ;kolko ma jeden prvok
               LD    (Dident),DE  ;typ var,array
               LD    (Ddim),HL    ;pocet prvkov

               LD    HL,0
               LD    (litptr),HL

               LD    HL,(Ddim)
               LD    A,H
               OR    L
               JR    NZ,$+6
               DEC   HL
               LD    (Ddim),HL
               LD    (savedim),HL
               LD    A,(static)
               AND   A
               JR    Z,statl
               CALL  getlabel
               LD    (autolab),HL
               CALL  postlabel
               JR    statl+3
statl:         CALL  entry
               LD    A,"="
               CALL  matches
               JP    NZ,neinic

               LD    A,"{"
               CALL  matches
               JR    NZ,doini

slucka:        LD    HL,(Ddim)    ; pojde o vycet
               LD    A,H
               OR    L
               JR    Z,neinic
               LD    BC,(dsize)
               LD    DE,(Dident)
               LD    A,(jj)
               CP    ARRAY
               JR    NZ,noar
               LD    A,(jj+1)
               CP    POINTER
               JR    NZ,noar
               LD    A,(stru2+15)
               CP    VARIABLE
               JR    NZ,noar
               CALL  init2        ; special
               LD    A,1
               LD    (dsize),A    ; dumplits like byte
               JR    noar2

noar:          CALL  init
               CALL  match
               DB    ","
               JR    Z,slucka
noar2:         LD    A,"}"
               CALL  needtoken
               JR    neinic

doini:         LD    BC,(dsize)
               LD    DE,(Dident)
               CALL  init

neinic:        LD    HL,(Ddim)
               LD    DE,(savedim)
               INC   HL
               INC   DE
               ADD   HL,DE
               LD    A,H
               OR    L
               JR    NZ,neza

               LD    DE,BPW
               LD    (dsize),DE
               CALL  stowlit
               LD    HL,POINTER
               LD    (Dident),HL

neza:          LD    A,(dsize)
               PUSH  AF
               CALL  dumplits
               POP   AF
               LD    HL,(Ddim)
               CALL  dumpzero
               LD    HL,(Dident)
               RET

init2:         PUSH  HL
               CALL  getlabel
               LD    (litlab),HL
init3:         LD    HL,0                ; startloop
               ADD   HL,SP
               PUSH  HL
               PUSH  HL
               LD    HL,(litptr)
               LD    (aktlit),HL

               LD    HL,msname       ; najprv mena
               CALL  symname
               JR    NC,inaky
               POP   HL
               POP   HL
               CALL  dodefw
               LD    HL,msname
               CALL  ol
               JR    init4

inaky:         POP   HL
               CALL  qstr
               POP   HL
               JR    Z,inakx

init5:         CALL  dodefw
               LD    HL,(litlab)
               CALL  printlabel
               LD    A,"+"
               CALL  outbyte
               DB    33
aktlit:        DW    0
               CALL  outdec
               CALL  nl

init4:         LD    HL,(Ddim)   ; endlop
               DEC   HL
               LD    (Ddim),HL
               LD    A,","
               CALL  matches
               JR    Z,init3
inay:          POP   HL
               LD    HL,(litlab)
               JP    postlabel

inakx:         CALL  constexpr
               POP   HL
               PUSH  HL
               JR    Z,inay
               LD    DE,(dsize)
               CALL  stowlit   ; value E= size , hl=value
               JR    init5

init:          PUSH  HL
               LD    HL,msname
               PUSH  BC
               PUSH  DE
               CALL  symname
               POP   DE
               POP   BC
               JR    NC,noname
               POP   HL
               CALL  dodefw
               LD    HL,msname
               CALL  ol
               JP    e12

noname:        LD    HL,0
               ADD   HL,SP
               PUSH  BC
               PUSH  DE
               PUSH  HL
               CALL  qstr
               POP   HL
               POP   DE
               POP   BC
               JR    Z,inak0

               LD    A,E
               CP    VARIABLE
               LD    (b2+1),A
               JR    Z,e1
               LD    A,(dtype)
               AND   MASK
               CP    CCHAR
               JR    Z,b1
e1:            CALL  error
               DM    "must assign to char pointer or array"
               NOP
b1:            POP   DE
               LD    HL,(litptr)
               AND   A
               SBC   HL,DE
               EX    DE,HL
               LD    HL,(Ddim)
               AND   A
               SBC   HL,DE
               LD    (Ddim),HL
b2:            LD    A,0
               CP    POINTER
               RET   NZ
               JP    point

inak0:         PUSH  BC
               PUSH  DE
               CALL  constexpr
               POP   DE
               POP   BC
               POP   HL
               RET   Z
               PUSH  HL
               LD    A,E
               CP    POINTER
               JR    NZ,e2
               PUSH  BC
               CALL  error
               DM    "can't assign to POINTER"
               NOP
               POP   BC
e2:            LD    D,0
               LD    E,C
               POP   HL
               CALL  stowlit
e12:           LD    HL,(Ddim)
               DEC   HL
               LD    (Ddim),HL
               RET

ndim:          LD    HL,parms
               INC   (HL)
               LD    A,(HL)
               DEC   A
               ADD   A
               LD    L,A
               LD    H,0
               LD    DE,dimenzie
               ADD   HL,DE
               LD    BC,(some)
               LD    (HL),C
               INC   HL
               LD    (HL),B
               RET

needsub:       LD    HL,1
               LD    (some2),HL
               XOR   A
               LD    (parms),A
needsub2:      CALL  match
               DB    "]"
               JP    Z,nula
               LD    HL,some
               CALL  constexpr
               LD    A,H
               OR    L
               LD    HL,(some)
               JR    NZ,$+5
               LD    HL,1
               LD    DE,(some2)
               CALL  CCUMUL
               LD    (some2),HL
               LD    A,H
               AND   A
               JP    P,posi
               CALL  error
               DM    "negative size illegal"
               NOP
               LD    HL,(some2)
               CALL  CCNEG
               LD    (some2),HL
posi:          CALL  ndim
               LD    A,"]"
               CALL  needtoken
               CALL  match
               DB    "["
               JR    Z,needsub2
               LD    A,(parms)
               CP    2
               CALL  NC,posi3
               LD    HL,(some2)
               RET

posi3:         LD    HL,dimenzie
m1:            DEC   A
               RET   Z
               PUSH  AF
               INC   HL
               INC   HL
               PUSH  HL
               LD    C,(HL)
               INC   HL
               LD    B,(HL)
               INC   HL
m2:            DEC   A
               JR    Z,m3
               CALL  dehl
               INC   HL
               PUSH  HL
               PUSH  AF
               LD    L,C
               LD    H,B
               CALL  CCMUL
               LD    C,L
               LD    B,H
               POP   AF
               POP   HL
               JR    m2
m3:            POP   HL
               DEC   HL
               LD    (HL),B
               DEC   HL
               LD    (HL),C
               INC   HL
               INC   HL
               POP   AF
               JR    m1

badarg:        CALL  warning
               DM    "wrong numbers of argument"
               NOP
               RET

setdiscard:    PUSH  DE
               EX    DE,HL
               LD    HL,(disptr)
               LD    (HL),E
               INC   HL
               LD    (HL),D
               INC   HL
               LD    (disptr),HL
               LD    (HL),0
               INC   HL
               LD    (HL),0
               EX    DE,HL
               POP   DE
               RET

disptr:        DW    end2

resdiscard:    PUSH  IX
               LD    IX,end2
resd5:         LD    L,(IX+0)
               LD    H,(IX+1)
               INC   IX
               INC   IX
               LD    A,H
               OR    L
               JR    Z,resd4
               LD    B,SYMMAX
               XOR   A
               LD    (HL),A
               INC   HL
               DJNZ  $-2
               JR    resd5

resd4:         POP   IX
               RET

initfnc:       XOR   A
               LD    H,A
               LD    L,A
               LD    (one),A
               LD    (nogo),A
               LD    (noloc),A
               LD    (lastst),A
               LD    A,(regflag)
               LD    (usereg),A
               LD    (litptr),HL
               LD    (stagenext),HL
               LD    HL,stage2
               LD    (pstage2),HL
               CALL  getlabel
               LD    (litlab),HL
               LD    HL,STARTLOC
               LD    (locptr),HL
               RET

rename:        LD    HL,ssname
               JP    findglb

definuj:       CALL  initfnc        ; navrat dovars
               CALL  rename
               JP    Z,neexist4

               LD    (ptr),HL       ; symbol je v tabulke
               LD    A,(HL)
               CP    FUNCTION
               PUSH  AF
               CALL  NZ,multidef    ; error ak nieje fnc
               POP   AF
               JP    NZ,opepa
                                   ;treba zmenit symbol
               PUSH  IX
               LD    IX,(ptr)
               LD    A,(jj)
               LD    (IX+IDENT),A
               LD    A,(jj+1)
               LD    (IX+IDENT2),A
               LD    A,(stru2+15)
               LD    (IX+IDENT3),A
               LD    A,(one)
               LD    (IX+ONE),A
               LD    A,(dtype)
               LD    (IX+TYPE),A
               XOR   A
               LD    (IX+OFFSET),A
               LD    (IX+OFFSET+1),A
               LD    (IX+EXTEND),A
               LD    (IX+EXTEND+1),A
               LD    (IX+PARMS),A
               LD    A,(dclas)
               LD    (IX+CLASS),A
               BIT   1,(IX+INFOBYTE) ; bola uz definovana ?
               CALL  NZ,multidef     ; error ak to je definicia
               POP   IX
               JP    opepa

neexist4:      LD    HL,ssname       ; bude sa zaznamenavat nova
               LD    (stru2),HL
               LD    HL,(jj)
               LD    (stru2+2),HL
               LD    HL,(dtype)
               LD    (stru2+4),HL
               LD    HL,0
               LD    (stru2+6),HL    ; offset
               LD    (stru2+12),HL   ; sizeof 0
               LD    HL,glbptr
               LD    (stru2+8),HL
               LD    HL,(dclas)
               LD    (stru2+10),HL
               CALL  addsym
               LD    (ptr),HL        ; save fnc symbol pointer
               JP    opepa

newfunc:       CALL  initfnc
               LD    A,STATIC
               LD    (dclas),A
               LD    HL,ssname
               CALL  symname
               JR    C,okline
               CALL  error
               DM    "Illegal function or declaration"
               DB    0
               JP    kill

okline:        CALL  rename
               JP    Z,neexist
               LD    (ptr),HL       ; symbol je v tabulke
               PUSH  HL
               EX    (SP),IX
               LD    A,(HL)
               CP    FUNCTION
               PUSH  AF
               PUSH  HL
               CALL  NZ,multidef    ; error ak nieje fnc
               POP   HL
               POP   AF
               JR    NZ,b3

               BIT   1,(IX+INFOBYTE) ; bola uz definovana ?
               CALL  NZ,multidef     ; error ak to je definicia
               LD    (IX+PARMS),0   ; pocitaj param
               LD    A,(dclas)
               LD    (IX+CLASS),A
               JR    b3

neexist:       LD    HL,ssname       ; bude sa zaznamenavat nova
               LD    (stru2),HL
               LD    HL,VARIABLE*256+FUNCTION
               LD    (stru2+2),HL
               LD    HL,CINT
               LD    (stru2+4),HL
               LD    HL,0
               LD    (stru2+6),HL    ; offset
               LD    (stru2+12),HL   ; sizeof 0
               LD    (stru2+14),HL   ; parms a id3
               LD    (extensia),HL   ; extensia
               LD    HL,glbptr
               LD    (stru2+8),HL
               LD    HL,(dclas)
               LD    (stru2+10),HL
               CALL  addsym
               LD    (ptr),HL        ; save fnc symbol pointer
               JR    b3+2

b3:            POP   IX
               LD    A,"("
               CALL  matches
               JR    Z,opepa
               CALL  error
               DM    "no open paren"
               NOP

opepa:         LD    HL,ssname
               LD    DE,fsname
               CALL  strcpy
               LD    HL,0
               LD    (argstk),HL
               LD    (csp),HL

whil12:        CALL  blanks
               CP    ")"
               JR    Z,b4     ; end of newfunc

               XOR   A
               LD    (unsigned),A
               CALL  elipsis
               JR    Z,elo
               CALL  settype
               JR    Z,zei2
               CALL  doargs   ; slucka pre deklarovanie premenych
               CALL  blanks
               CP    ")"
               JR    Z,b4
               LD    A,","
               CALL  matches
               JR    Z,whil12
               CALL  error
               DM    "no coma"
               NOP
               CALL  endst
               JR    Z,whil12

zei2:          CALL  b10      ; bad argument name
               JR    b4
elo:           CALL  b9       ; elipsis = variadic
               LD    (HL),-1

b4:            LD    A,")"
               CALL  needtoken
               CALL  blanks
               CP    "{"
               JP    NZ,ns         ; islo o prototyp

               LD    A,1
               LD    (discard2),A  ; vsetko staticke bude disc...
               LD    HL,0
               LD    (end2),HL
               LD    HL,end2
               LD    (disptr),HL
               LD    HL,fsname     ; urob fciu
               CALL  entry+3
               CALL  saver
               CALL  nl
               CALL  statement
               CP    Treturn
               CALL  NZ,ffret
               CALL  resdiscard
               CALL  lit
               RET

lit:           LD    HL,0
               LD    (csp),HL
               XOR   A
               LD    (argc),A      ; a ccargc zase neplati
               LD    (discard2),A
               INC   A
               LD    (intf),A
               PUSH  IY
               LD    IY,(ptr)
               SET   1,(IY+INFOBYTE)  ; definovana
               POP   IY
               LD    A,(test2)
               BIT   0,A
               CALL  NZ,cntrl         ; if pragma test
               LD    HL,(pstage2)
               LD    DE,stage2
               AND   A
               SBC   HL,DE
               EX    DE,HL
               CALL  NZ,os         ; out if stage2 using
               LD    HL,(litptr)
               LD    A,H
               OR    L
               RET   Z
               LD    HL,(litlab)
               CALL  postlabel
               LD    A,1
               JP    dumplits

cntrl:         LD    HL,STARTLOC
               LD    BC,INFOBYTE

cn1:           DB    &11    ; kontroluje vsetky premenne za prvym
m8:            DW    0
               AND   A
               SBC   HL,DE
               ADD   HL,DE
               RET   NC
               ADD   HL,BC
               BIT   2,(HL)
               LD    DE,NAME-INFOBYTE
               CALL  Z,unused
               ADD   HL,DE
               LD    A,(HL)
               INC   HL
               CP    " "
               JR    NC,$-4
               JR    cn1

unused:        PUSH  HL
               PUSH  DE
               PUSH  BC
               ADD   HL,DE
               LD    DE,xname
unu3:          LD    A,(HL)
               CP    " "
               JR    C,unu4
               LDI
               JR    unu3
unu4:          XOR   A
               LD    (DE),A
               LD    (errflag),A    ; multi error
               INC   DE
               LD    A,201
               LD    (DE),A
               CALL  warn
               POP   BC
               POP   DE
               POP   HL
               RET

warn:          CALL  warning
               DM    "unused variable "
xname:         DS    NAMESIZE
               NOP
               RET

doargs:        LD    (dtype),A     ; A=type
               BIT   7,A
               CALL  NZ,dostruct
               CALL  blanks
               CP    ")"
               RET   Z             ; ( void ) ...

               CALL  ispoints
               LD    A,"("
               CALL  matches
               LD    (func1),A
               LD    A,FUNCTION
               CALL  Z,setjj
               CALL  ispoints
               CALL  ispoints

               LD    HL,ssname
               CALL  symname
               LD    (legal),A
               CALL  NC,illname
               LD    A,(func1)
               AND   A
               LD    A,")"
               CALL  Z,matches    ; ukazatel

               LD    A,"("        ; ukazatel na funkciu
               CALL  matches
               JR    NZ,bt
               CALL  spocitaj
               LD    A,(parms)
               LD    (stru2+14),A

bt:            LD    A,"["
               CALL  matches
               JR    NZ,b7        ; ukazatel na pole rozmery !!!!
               CALL  needsub        ; ide o pole
               LD    A,(parms)
               LD    (stru2+14),A
               CP    2
               JR    C,be
               ADD   A
               LD    C,A
               LD    B,0
               LD    HL,dimenzie
               CALL  toextbuf
               LD    (extensia),HL
be:            LD    A,POINTER    ; poiter to pointer
               CALL  setjj

b7:            LD    A,(legal)
               AND   A
               JR    Z,b10        ; error

               LD    HL,ssname
               CALL  findloc
               PUSH  AF
               CALL  NZ,multidef     ; su dva rovnake
               POP   AF
               LD    A,(jj)
               CP    VARIABLE
               LD    A,(dtype)
               JR    NZ,nose
               BIT   7,A
               JR    Z,nose
               CP    CENUM
               JR    Z,nose          ; enum nieje structs
               CALL  error
               DM    "struct can't be parameter"
               NOP
nose:          CALL  setsize
               LD    (stru2+12),HL
               LD    HL,ssname
               LD    (stru2),HL
               LD    HL,(jj)
               LD    (stru2+2),HL
               LD    HL,(dtype)
               LD    (stru2+4),HL
               LD    HL,(argstk)
               LD    (stru2+6),HL
               LD    HL,locptr
               LD    (stru2+8),HL
               LD    HL,AUTOMATIC
               LD    (stru2+10),HL
               CALL  setone
               CALL  addsym          ; pridaj implicint int fnc
               LD    HL,(argstk)
               INC   HL
               INC   HL
               LD    (argstk),HL
b9:            LD    HL,(ptr)
               LD    DE,PARMS
               ADD   HL,DE
               INC   (HL)
               RET

b10:           CALL  error
               DM    "illegal argument name"
               NOP
               CALL  junk
               RET

statement:     LD    A,(ch)
               AND   A
               JR    NZ,noeof
               LD    A,(eof)
               AND   A
               RET   NZ

noeof:         CALL  variables
               JR    NZ,endsta      ; islo o premennu

               LD    A,(declared+1)
               AND   A
               JP    M,nodecla

decla:         LD    A,(ncmp)   ; declared je kladne
               CP    2
               JR    C,$+8      ; goto len na prvej urovni
               LD    A,(declared)
               LD    (nogo),A
               JR    NC,$+8+6
               LD    HL,0       ; reset static literals
               LD    (litptr),HL
               CALL  getlabel
               LD    (litlab),HL
               LD    HL,(csp)
               LD    DE,(declared)
               XOR   A
               SBC   HL,DE
               CALL  modstk
               LD    (csp),HL
               LD    HL,-1
               LD    (declared),HL

nodecla:       LD    A,"{"
               CALL  matches
               JR    NZ,stx
               CALL  compound
               JR    endsta

stx:           LD    HL,tabcom2
               CALL  dotok
               LD    A,H
               OR    L
               JR    Z,st12
               LD    A,C           ; spust prikaz ak si nasiel
               LD    (lastst),A
               PUSH  HL
               CALL  preskoc
               POP   HL
               CALL  jphl
               JR    endsta
svsta:         LD    (lastst),A
endsta:        LD    A,(lastst)
               RET

st12:          CALL  dolabel
               JR    NZ,endsta      ; je to navestie
               CALL  doexpr
               CALL  ns
               LD    A,STEXPR
               JR    svsta

doreturn2:     CALL  doreturn
               JP    ns

dobreak2:      CALL  dobreak
               JP    ns

docont2:       CALL  docont
               JP    ns

empty:         XOR   A
               LD    (errflag),A   ; a uz mozes zase robit chyby
               JP    endsta

preskoc:       LD    A,1
               JP    bump

nt:            CALL  error
               DM    "typedef on local not allowed"
               NOP
               RET

variables:     XOR   A              ; urob lokal blok vars
               LD    (register),A
               LD    (static),A
               LD    (unsigned),A
               LD    A,Ttypedef
               CALL  matches
               CALL  Z,nt
               LD    A,Textern      ; externe definicie
               CALL  matches
               JR    NZ,var0
               LD    HL,static
               LD    (HL),EXTERNAL
               JR    var2
var0:          LD    A,Tregister
               CALL  matches
               JR    NZ,var1
               INC   A
               LD    (register),A   ; ide o registrovu
               JR    var2
var1:          LD    A,Tstatic
               CALL  matches
               JR    NZ,var6
               LD    HL,static
               LD    (HL),STATIC
               JR    var2
var6:          LD    A,Tauto        ; pre istotu
               CALL  matches

var2:          CALL  settype      ; pametovu triedu uz mame
               RET   Z            ; neslo ani o unsigned
               LD    C,A          ; a = type
               LD    A,(static)
               AND   A
               LD    B,A          ; B=pametova trieda
               LD    A,C
               JR    NZ,globvar    ; skok ak autostatic

               CALL  declloc
               CALL  ns
               JP    jedna

globvar:       PUSH  HL
               PUSH  HL
               PUSH  AF
               PUSH  BC
               LD    HL,4
               ADD   HL,SP
               LD    D,H
               LD    E,L
               INC   DE
               INC   DE
               CALL  setstage
               POP   BC
               POP   AF
               CALL  declglb      ; staticka or extern  lokalna
               XOR   A
               LD    (static),A
               POP   DE
               LD    HL,(stagenext)
               LD    A,H
               OR    L
               JR    Z,$+4
               LD    (HL),0
               POP   HL
               PUSH  DE

               LD    DE,(pstage2)
               CALL  strcpy
               DEC   DE
               LD    (pstage2),DE

               POP   HL
               LD    DE,0
               CALL  clearstage
               JP    jedna

strcpy:        LD    A,(HL)
               LDI
               AND   A
               RET   Z
               JR    strcpy


ns:            LD    A,";"
               CALL  matches
               JR    Z,tns

               CALL  warning
               DM    "no semicolon"
               DB    0
               RET
tns:           XOR   A
               LD    (errflag),A
               RET

compound:      LD    HL,(locptr)
               PUSH  HL
               LD    HL,(csp)
               PUSH  HL
               LD    HL,0
               LD    (declared),HL
               LD    HL,ncmp
               INC   (HL)

next.coma:     LD    A,"}"
               CALL  matches
               JR    Z,ccu

               LD    A,(eof)
               AND   A
               JR    Z,doco
               CALL  error
               DM    "no final }"
               NOP
               JR    ccu

doco:          CALL  statement
               JR    next.coma

ccu:           LD    HL,ncmp
               DEC   (HL)
               POP   HL           ; eval savcsp
               JR    Z,$+7
               LD    A,0          ; } neposledny lastst=0
               LD    (lastst),A
               JR    NZ,nomods2    ; najvonkajsi
               LD    A,(lastst)
               CP    Treturn
nomods2:       LD    A,NO
               CALL  NZ,modstk

               LD    (csp),HL
               POP   HL
               PUSH  HL
               LD    (cptr),HL

a2:            LD    HL,(cptr)
               LD    DE,(locptr)
               AND   A
               SBC   HL,DE
               JR    NC,uko

               LD    HL,(cptr)
               PUSH  HL
               CALL  nextsym
               LD    (cptr2),HL
               POP   HL
               LD    A,(HL)
               CP    LABEL
               JR    NZ,inak1

               LD    HL,(cptr)
               POP   DE
               LD    A,(HL)
               LDI
               CP    " "
               JR    NC,$-5
               PUSH  DE

inak1:         LD    HL,(cptr2)
               LD    (cptr),HL

uko:           POP   HL            ; eval savloc
               LD    DE,(locptr)
               LD    (m8),DE
               LD    (locptr),HL
               LD    DE,-1
               LD    (declared),DE
               RET

doif:          PUSH  HL
               CALL  getlabel
               PUSH  HL
               LD    A,YES
               CALL  test
               CALL  statement
               CALL  match
               DB    Telse
               JR    Z,ajelse
               POP   HL
               POP   BC
               JP    postlabel

ajelse:        CALL  getlabel
               POP   BC
               POP   DE
               PUSH  HL
               PUSH  BC

               LD    A,(lastst)
               CP    Tgoto
               JR    Z,bezsk
               CP    Treturn
               JR    Z,bezsk
               CALL  jump
bezsk:         POP   HL
               CALL  postlabel
               CALL  statement
               POP   HL
               JP    postlabel

doexpr:        LD    HL,-8
               ADD   HL,SP
               LD    SP,HL
               PUSH  HL
               EX    (SP),IX

whil6:         PUSH  IX
               POP   HL
               LD    D,H
               LD    E,L
               INC   DE
               INC   DE
               CALL  setstage

               PUSH  IX
               POP   HL

               INC   HL
               INC   HL
               INC   HL
               INC   HL
               LD    D,H
               LD    E,L
               INC   DE
               INC   DE

               PUSH  IX
               CALL  expression
               POP   IX

               LD    E,(IX+0)
               LD    D,(IX+1)
               EX    DE,HL
               LD    E,(IX+2)
               LD    D,(IX+3)
               CALL  clearstage

               LD    A,(ch)
               CP    ","
               JR    NZ,finw
               LD    A,1
               CALL  bump
               JR    whil6

finw:          POP   IX
               LD    HL,8
               ADD   HL,SP
               LD    SP,HL
               RET

dowhile:       LD    HL,-8
               ADD   HL,SP
               LD    SP,HL
               PUSH  HL
               EX    DE,HL
               CALL  addwhile
               EX    (SP),IX
               LD    L,(IX+WQLOOP)
               LD    H,(IX+WQLOOP+1)
               CALL  postlabel
               LD    L,(IX+WQEXIT)
               LD    H,(IX+WQEXIT+1)
               LD    A,YES
               PUSH  HL
               CALL  test
               CALL  callesc
               CALL  statement
               LD    L,(IX+WQLOOP)
               LD    H,(IX+WQLOOP+1)
               CALL  jump
               POP   HL
               CALL  postlabel

               POP   IX
               LD    HL,8
               ADD   HL,SP
               LD    SP,HL
               JP    delwhile

dodo:          LD    HL,-8
               ADD   HL,SP
               LD    SP,HL
               EX    DE,HL
               PUSH  DE
               CALL  addwhile
               CALL  getlabel
               POP   DE
               PUSH  HL
               PUSH  DE
               EX    (SP),IX
               CALL  postlabel
               CALL  callesc
               CALL  statement

               LD    A,Twhile
               CALL  needtoken
               LD    L,(IX+WQLOOP)
               LD    H,(IX+WQLOOP+1)
               CALL  postlabel

               LD    L,(IX+WQEXIT)
               LD    H,(IX+WQEXIT+1)
               LD    A,YES
               PUSH  HL
               CALL  test
               LD    L,(IX-2)
               LD    H,(IX-1)
               CALL  jump
               POP   HL
               CALL  postlabel
               CALL  ns

               POP   IX
               LD    HL,8+2
               ADD   HL,SP
               LD    SP,HL
               RET

dofor:         LD    HL,-8
               ADD   HL,SP
               LD    SP,HL
               EX    DE,HL
               CALL  addwhile
               CALL  getlabel
               PUSH  HL
               CALL  getlabel
               PUSH  HL

               LD    A,"("
               CALL  needtoken
               CALL  match
               DB    ";"
               JR    Z,a4
               CALL  doexpr
               CALL  ns

a4:            POP   DE
               POP   HL
               PUSH  HL
               PUSH  DE
               CALL  postlabel
               CALL  match
               DB    ";"
               JR    Z,a5

               LD    HL,4+WQEXIT
               ADD   HL,SP
               CALL  hlhl
               LD    A,NO
               CALL  test
               CALL  ns

a5:            POP   HL
               PUSH  HL
               CALL  jump
               LD    HL,4+WQLOOP
               ADD   HL,SP
               CALL  hlhl
               CALL  postlabel

               CALL  match
               DB    ")"
               JR    Z,a6
               CALL  doexpr
               LD    A,")"
               CALL  needtoken

a6:            POP   BC
               POP   HL
               PUSH  BC
               CALL  jump
               POP   HL
               CALL  postlabel
               CALL  callesc
               CALL  statement
               LD    HL,WQLOOP
               ADD   HL,SP
               CALL  hlhl
               CALL  jump
               LD    HL,WQEXIT
               ADD   HL,SP
               CALL  hlhl
               CALL  postlabel
               LD    HL,8
               ADD   HL,SP
               LD    SP,HL
               JP    delwhile

doswitch:      LD    HL,-8
               ADD   HL,SP
               LD    SP,HL
               LD    HL,(swactive)
               PUSH  HL
               LD    HL,(swdefault)
               PUSH  HL
               LD    HL,(swnext)
               PUSH  HL
               PUSH  HL

               LD    A,1
               LD    (swactive),A
               LD    HL,4*2    ; wq
               ADD   HL,SP
               EX    DE,HL
               CALL  addwhile
               LD    HL,(wqptr)
               LD    DE,WQLOOP-WQSIZ
               ADD   HL,DE
               LD    (HL),0
               INC   HL
               LD    (HL),0

               LD    A,"("
               CALL  needtoken
               CALL  doexpr
               LD    A,")"
               CALL  needtoken

               LD    HL,0
               LD    (swdefault),HL
               INC   HL
               LD    (swactive),HL
               CALL  getlabel
               PUSH  HL
               CALL  jump
               CALL  statement
               LD    HL,5*2+WQEXIT
               ADD   HL,SP
               CALL  hlhl
               CALL  jump
               POP   HL
               CALL  postlabel
               CALL  sw

whil15:        POP   HL
               PUSH  HL
               LD    DE,(swnext)
               AND   A
               SBC   HL,DE
               JP    Z,c4
               ADD   HL,DE
               LD    A,CINT/4
               CALL  defstorage
               POP   HL
               CALL  dehl
               INC   HL
               PUSH  HL
               EX    DE,HL
               CALL  printlabel
               LD    A,","
               CALL  outbyte
               POP   HL
               CALL  dehl
               INC   HL
               PUSH  HL
               EX    DE,HL
               CALL  outdec
               CALL  nl
               JR    whil15

c4:            LD    A,CINT/4
               CALL  defstorage
               LD    HL,0
               CALL  outdec
               CALL  nl
               LD    HL,(swdefault)
               LD    A,H
               OR    L
               CALL  NZ,jump
               LD    HL,4*2+WQEXIT
               ADD   HL,SP
               CALL  hlhl
               CALL  postlabel
               CALL  delwhile
               POP   HL         ; del swptr
               POP   HL
               LD    (swnext),HL
               POP   HL
               LD    (swdefault),HL
               POP   HL
               LD    (swactive),HL

               LD    HL,8
               ADD   HL,SP
               LD    SP,HL
               RET

docase:        LD    A,(swactive)
               AND   A
               JR    NZ,bezch
               CALL  error
               DM    "not in switch"
               NOP
bezch:         LD    HL,(swend)
               LD    DE,(swnext)
               AND   A
               SBC   HL,DE
               JR    NC,too
               CALL  error
               DM    "too many cases"
               NOP
               RET
too:           CALL  getlabel
               EX    DE,HL
               CALL  hlde
               INC   HL
               LD    (swnext),HL
               EX    DE,HL
               CALL  postlabel
               LD    HL,(swnext)
               PUSH  HL
               CALL  constexpr
               POP   HL
               INC   HL
               INC   HL
               LD    (swnext),HL
               LD    A,":"
               JP    needtoken

dodefault:     LD    A,(swactive)
               AND   A
               JR    Z,noti
               LD    HL,(swdefault)
               LD    A,H
               OR    L
               JR    Z,okse
               CALL  warning
               DM    "multiple defaults"
               NOP
               JR    okse

noti:          CALL  error
               DM    "not in switch"
               NOP

okse:          LD    A,":"
               CALL  needtoken
               CALL  getlabel
               LD    (swdefault),HL
               CALL  postlabel
               RET

dogoto:        LD    A,(nogo)
               CP    1
               JR    NC,goer
               LD    A,1
               LD    (noloc),A
               JR    dogo1
goer:          CALL  error
               DM    "not allowed with block-locals"
               NOP
dogo1:         LD    HL,ssname
               CALL  symname
               JR    NC,a7
               CALL  addlabel
               CALL  jump
               JP    ns
a7:            CALL  error
               DM    "bad label"
               NOP
               JP    ns

dolabel:       CALL  blanks         ; vracia 1 a 0 podla to ci je
               LD    HL,(lptr)      ; to LABEL
               PUSH  HL
               LD    HL,ssname
               CALL  symname
               JR    NC,c2
               CALL  gch
               CP    ":"
               JR    NZ,c2
               CALL  addlabel
               CALL  postlabel
               POP   HL
               JP    jedna

c2:            POP   HL
               CALL  bump2   ; obnovi lptr
               JP    nula

addlabel:      LD    HL,ssname   ; vracia navestie cislo v HL
               CALL  findglb
               LD    (cptr),HL
               JR    Z,c0
               LD    A,(HL)
               CP    LABEL
               JR    Z,c1
               CALL  error
               DM    "not a label"
               NOP
               JR    c1

c0:            LD    HL,ssname      ; skok dopredu
               LD    (stru2),HL
               LD    HL,LABEL
               LD    (stru2+2),HL
               LD    (stru2+4),HL
               CALL  getlabel
               LD    (stru2+6),HL
               LD    HL,glbptr
               LD    (stru2+8),HL
               LD    HL,LABEL
               LD    (stru2+10),HL
               LD    A,1
               LD    (discard2),A
               CALL  addsym

c1:            LD    HL,(cptr)
               INC   HL
               INC   HL
               INC   HL
               JP    hlhl

doreturn:
               CALL  endst
               JR    NZ,bezpa
               CALL  doexpr
               LD    A,YES
               JR    bezpa+2

bezpa:         LD    A,NO
               LD    HL,0
               CALL  modstk
               CALL  callesc
               JP    ffret

dobreak:       LD    HL,(wqptr)
               CALL  readwhile
               LD    A,H
               OR    L
               RET   Z
               PUSH  HL
               EX    (SP),IX
               LD    E,(IX+WQSP)
               LD    D,(IX+WQSP+1)
               EX    DE,HL
               LD    A,NO
               CALL  modstk
               LD    E,(IX+WQEXIT)
               LD    D,(IX+WQEXIT+1)
               EX    DE,HL
               POP   IX
               JP    jump

docont:        LD    HL,(wqptr)
               CALL  readwhile
               LD    A,H
               OR    L
               RET   Z
               EX    DE,HL
               LD    HL,WQLOOP
               ADD   HL,DE
               LD    C,(HL)
               INC   HL
               LD    B,(HL)
               EX    DE,HL
               LD    A,B
               OR    C
               JR    Z,docont+3
               PUSH  BC
               CALL  hlhl
               LD    A,NO
               CALL  modstk
               POP   HL
               JP    jump

doasm:         XOR   A
               LD    (ccode),A
               CALL  inline
               LD    A,T#endasm
               CALL  matches
               JR    Z,konas

               LD    A,(eof)
               AND   A
               JR    NZ,konas
               LD    HL,(line)
               CALL  OUTBUF
               JR    doasm+4

konas:         CALL  kill
               LD    A,1
               LD    (ccode),A
               RET

junk:          CALL  inbyte
               CALL  an
               JR    NC,bie
a1:            LD    A,(ch)
               CALL  an
               JP    NC,blanks
               CALL  gch
               JR    a1

bie:           LD    A,(ch)
               CALL  an
               JP    C,blanks
               AND   A
               RET   Z
               CALL  gch
               JR    bie

endst:         CALL  blanks
               CP    ";"        ; vracia 1:0 v A
               JP    Z,jedna
               LD    A,(ch)
               AND   A
               JP    Z,jedna
               JP    nula

illname:       CALL  error
               DM    "illegal symbol"
               DB    0
               JP    junk

shname:        CALL  warning
               DM    "short name"
               NOP
               RET

multidef:
               CALL  warning
               DM    "already defined"
               DB    0
               RET

needtoken:     LD    (nedf+1),A        ; reg. A
               CALL  matches
               RET   Z

               CALL  error
               DM    "missing token "
nedf:          DB    34,0,34,0
               XOR   A
               INC   A
               RET

needlval:      CALL  error
               DM    "l-value required"
               NOP
               RET

findglb:       LD    (stru),HL      ; HL = adr symbolu
               LD    HL,STARTGLB
               LD    (stru+2),HL
               LD    HL,SYMMAX
               LD    (stru+4),HL
               LD    HL,ENDGLB
               LD    (stru+6),HL
               LD    HL,NUMGLBS
               LD    (stru+8),HL
               LD    HL,NAME
               LD    (stru+10),HL
               CALL  search
               JP    Z,nula
               LD    HL,(cptr)
               RET

findloc:       LD    (strr+1),HL      ; HL =ssname

               LD    HL,(locptr)
               DEC   HL               ; HL =0 ak nenasiel
               LD    (cptr),HL

whil1:         LD    HL,STARTLOC
               LD    DE,(cptr)
               AND   A
               SBC   HL,DE
               JR    C,oklo         ; bola cela tabulka ?

nula:          XOR   A
               LD    H,A
               LD    L,A
               RET

jedna:         XOR   A
               LD    H,0
               INC   A
               LD    L,A
               RET

oklo:          EX    DE,HL
               LD    C,(HL)      ; hl = cptr
               LD    B,0
               AND   A
               SBC   HL,BC       ; na zaciatok mena
               PUSH  HL
               EX    DE,HL

strr:          LD    HL,0
               LD    B,C
               CALL  astreq
               POP   HL         ; cptr- NAME
               LD    DE,NAME
               AND   A
               SBC   HL,DE      ; hl = table item
               AND   A
               RET   NZ

               DEC   HL
               LD    (cptr),HL
               JR    whil1

addsym:        LD    HL,(stru2+8)
               LD    DE,glbptr
               AND   A
               SBC   HL,DE
               JR    NZ,lokalne

               LD    HL,(stru2)
               CALL  findglb
               LD    (cptr2),HL
               RET   NZ          ; vrat sa ak uz existuje
               LD    HL,(global)
               INC   HL
               LD    (global),HL
               LD    HL,(cptr)
               LD    A,H
               OR    L
               JR    NZ,okglb
               CALL  error
               DM    "global symbol table overflow"
               DB    0
               JP    abort

lokalne:       LD    DE,ENDLOC-SYMMAX
               LD    HL,(locptr)
               AND   A
               SBC   HL,DE
               JR    C,novela
               CALL  error
               DM    "local symbol table overflow"
               NOP
               JP    abort

novela:        LD    HL,(locptr)
               LD    (cptr),HL

okglb:         PUSH  IX
               LD    IX,(cptr)
               LD    A,(stru2+2)
               LD    (IX+IDENT),A
               LD    A,(stru2+3)
               LD    (IX+IDENT2),A
               LD    A,(stru2+15)
               LD    (IX+IDENT3),A
               LD    A,(one)
               LD    (IX+ONE),A
               LD    A,(stru2+4)
               LD    (IX+TYPE),A
               LD    A,(stru2+10)
               LD    (IX+CLASS),A
               LD    A,MASK
               AND   (IX+TYPE)
               JR    Z,nointch
               LD    A,(IX+TYPE)
               AND   1
nointch:       LD    B,A
               LD    A,(unsigned)
               OR    B
               LD    (IX+INFOBYTE),A
               LD    A,(constf)
               AND   A
               JR    Z,r56
               SET   6,(IX+INFOBYTE)  ; const
r56:           LD    A,(discard2)
               AND   A
               JR    Z,r57
               SET   5,(IX+INFOBYTE)  ;discardable
               PUSH  IX
               POP   HL
               LD    DE,STARTGLB
               AND   A
               SBC   HL,DE
               ADD   HL,DE
               JR    C,r57
               CALL  setdiscard    ; iba globalne symboly
               LD    HL,(global)
               DEC   HL
               LD    (global),HL

r57:           LD    HL,(stru2+12)
               LD    (IX+SIZEOF),L
               LD    (IX+SIZEOF+1),H
               LD    A,(stru2+14)
               LD    (IX+PARMS),A
               LD    HL,(extensia)
               LD    (IX+EXTEND),L
               LD    (IX+EXTEND+1),H
               LD    HL,(menovka)
               LD    (IX+MENOSTR),L   ; save menovky
               LD    (IX+MENOSTR+1),H
               LD    HL,0
               LD    (extensia),HL
               POP   IX

               LD    HL,(cptr)
               PUSH  HL
               LD    DE,OFFSET
               ADD   HL,DE
               LD    DE,(stru2+6)
               LD    (HL),E
               INC   HL
               LD    (HL),D
               POP   HL
               LD    DE,NAME
               ADD   HL,DE
               LD    (cptr2),HL
               LD    (cptr3),HL
               EX    DE,HL
               LD    HL,(stru2)
               LD    B,0

setlen:        LD    A,(HL)
               CALL  an
               JR    NC,kons
               INC   B
               LD    (DE),A
               INC   HL
               INC   DE
               JR    setlen

kons:          LD    A,B
               LD    BC,locptr
               LD    HL,(stru2+8)
               AND   A
               SBC   HL,BC
               JR    NZ,neglo

               LD    (DE),A       ; nastav dlzku mena u lokalnej
               INC   DE
               LD    (locptr),DE  ; a uloz

neglo:         LD    HL,(cptr)
               XOR   A
               INC   A
               RET

nextsym:       LD    DE,NAME      ; HL = polozka
               ADD   HL,DE
nextlo:        LD    A,(HL)
               INC   HL
               CP    " "
               JR    NC,nextlo
               RET             ; HL = koniec mena

symname:       PUSH  HL        ; vracia CY =1 ak OK
               CALL  blanks    ; kopiruje text na HL
               CALL  alpha     ; a kontroluje moznost symbolu
               POP   HL
               LD    A,0
               LD    (HL),A
               RET   NC

               LD    DE,(lptr)
               LD    B,0

syml:          LD    A,(DE)
               CALL  an
               JR    NC,nej
               LD    (HL),A
               INC   HL
               INC   DE
               INC   B
               LD    A,NAMESIZE
               CP    B
               JR    NZ,syml

endsym:        LD    A,(DE)
               CALL  an
               JR    NC,nej
               INC   DE
               JR    endsym

nej:           LD    (HL),0
               LD    A,B
               LD    (wde+1),A
               EX    DE,HL
               CALL  cbum1     ; lptr ukazuje za meno
               SCF            ; ch=next char
wde:           LD    A,0
               RET

getlabel:      LD    HL,(nxtlab)
               INC   HL
               LD    (nxtlab),HL
               DEC   HL
               RET

postlabel:     CALL  printlabel
               LD    A,":"
               CALL  outbyte
               JP    nl

printlabel:    PUSH  HL
               LD    A,(prefix)
               CALL  outbyte
               LD    A,(prefix+1)
               CALL  outbyte
               POP   HL
               JP    outdec1

alpha:         CP    "A"     ; CY=1 if OK
               CCF
               RET   NC
               CP    "Z"+1
               RET   C
               CP    "_"
               SCF
               RET   Z
lower:         CP    "a"
               CCF
               RET   NC
               CP    "z"+1
               RET

an:            CALL  alpha    ; CY = 1 OK
               RET   C

isnum:         CP    "0"
               CCF
               RET   NC
               CP    "9"+1
               RET

isoct:         CP    "0"
               CCF
               RET   NC
               CP    "8"
               RET

ishex:         CALL  isnum
               RET   C
               LD    A,B
               CP    10
               RET   Z      ; desiatkova sustava
               CP    8
               RET   Z
               CP    2
               RET   Z
               LD    A,(DE)
               CP    "A"
               CCF
               RET   NC
               CP    "F"+1
               RET   C
               RES   5,A
               CP    "A"
               CCF
               RET   NC
               CP    "F"+1
               RET

ldtohl:        LD    (HL),E
               INC   HL
               LD    (HL),D
               INC   HL
               RET

addwhile:      LD    HL,(wqptr)     ; DE = adr pola
               PUSH  HL
               PUSH  DE
               LD    DE,(csp)
               CALL  ldtohl
               EX    DE,HL
               CALL  getlabel
               EX    DE,HL
               CALL  ldtohl
               EX    DE,HL
               CALL  getlabel
               EX    DE,HL
               CALL  ldtohl
               LD    (wqptr),HL
               LD    DE,WQMAX

               AND   A
               SBC   HL,DE
               ADD   HL,DE
               JR    NC,toom
               POP   DE
               POP   HL
               LD    BC,WQSIZ    ; urob si aj kopiu
               LDIR
               RET

toom:          CALL  error
               DM    "too many active loops"
               DB    0
               CALL  abort
               RET

delwhile:      LD    HL,(wqptr)
               LD    DE,wq
               AND   A
               SBC   HL,DE
               ADD   HL,DE
               RET   Z

               LD    DE,WQSIZ
               SBC   HL,DE
               LD    (wqptr),HL
               RET

readwhile:     EX    DE,HL     ; HL = wqptr
               LD    HL,wq
               AND   A
               SBC   HL,DE
               JR    C,okwh

               CALL  error
               DM    "out of context"
               NOP
               LD    HL,0
               RET

okwh:          LD    HL,-WQSIZ
               ADD   HL,DE      ; HL = posledna slucka
               RET

white:         LD    HL,(lptr)  ; CY= 1 ak WHITE
               LD    A,(HL)
               AND   A
               RET   Z

               CP    "!"
               RET

gch:           LD    A,(ch)      ; vracia A
               PUSH  AF
               LD    A,1
               CALL  bump
               POP   AF
               RET

bump:          AND   A           ; a= 0..127
               JR    Z,nbum
               LD    E,A
               LD    D,0
bump1:         LD    HL,(lptr)  ; DE= -1..-32768
               ADD   HL,DE
bump2:         LD    (lptr),HL
               JR    cbum

nbum:          LD    HL,(line)
cbum1:         LD    (lptr),HL

cbum:          LD    A,(HL)
               LD    (ch),A
               LD    (nch),A
               AND   A
               RET   Z
               INC   HL
               LD    A,(HL)
               LD    (nch),A
               RET

kill:          XOR   A
               LD    HL,(line)
               LD    (HL),0
               JP    bump

inbyte:        LD    A,(ch)  ; vracia dalsi znak
               AND   A       ; ak treba vola vstup riadku
               JP    NZ,gch  ; vracia 0 ak koniec vstupu
               LD    A,(eof)
               AND   A
               LD    A,0
               RET   NZ
               CALL  preprocess
               JR    inbyte

inline:        LD    A,&F7
               IN    A,(&F9)
               AND   32
               JP    Z,abort  ; abort if ESCAPE pressed
               LD    A,(input)
               CP    EOF
               RET   Z

nieu:          CALL  fgets
               CP    &1A     ; koniec suboru  ?

               LD    A,0
               JP    NZ,bump

               LD    A,(input2) ; islo o include ?
               CP    EOF
               LD    A,EOF
               JR    Z,neslo

               LD    (input2),A
               JR    praz

neslo:         LD    (input),A
               LD    (eof),A           ; koniec kompilacie !!!!

praz:          XOR   A
               LD    HL,(line)
               LD    (HL),A
               JP    bump

loadpoint:     LD    A,(input2)
               CP    EOF
               LD    HL,source+3
               RET   NZ
               LD    HL,source
               RET

setps:         EX    AF,AF'
               IN    A,(251)
               LD    (sourcx),A
               LD    (sourcx+1),HL
               EX    AF,AF'
               RET

fgets:         LD    BC,251  ; pokus sa z input2 az potom
               IN    B,(C)   ; z input
               PUSH  BC      ; vysledok je v reg. a
               CALL  loadpoint
               PUSH  HL
               LD    A,(HL)
               INC   HL
               OUT   (251),A ; nastrankuj to
               CALL  hlhl
               LD    DE,(line)
                            ; de = kam
newl:          LD    A,(HL)
               CALL  setps
               CP    EOF
               JR    Z,endg  ; koniec suboru
               INC   HL      ; preskoc tabulator
               LD    A,(HL)
               CP    13
               JR    NZ,fgetl
               INC   HL      ; islo o prazdny riadok
               JR    newl

fgetl:         LD    A,(HL)
               LDI
               CP    EOL
               JR    Z,endg
               JR    fgetl

endg:          EX    DE,HL
               LD    (HL),0   ; EOL + NULL
               POP   HL
               BIT   6,D
               JR    Z,bezu
               RES   6,D
               INC   (HL)

bezu:          INC   HL
               LD    (HL),E
               INC   HL
               LD    (HL),D
               CALL  plusl       ; pocita sa vsetko

noli:          POP   BC
               OUT   (C),B
               RET

plusl:         PUSH  HL
               LD    HL,(liness)
               INC   HL
               LD    (liness),HL
               POP   HL
               RET

fopen:         LD    DE,sd        ; navrat addr
               LD    (loopv),DE
               LD    (callsp),SP
               LD    A,3          ; sluzba cislo 3
               RES   7,H
               JP    volaj        ; hl ukazuje na nazov
sd:                              ; a=0 alebo EOF
               PUSH  AF
               LD    A,C
               LD    (source+3),A
               LD    (source+4),DE
               POP   AF
               RET

zavol:         LD    DE,sq
               LD    (loopv),DE
               SET   7,H
               PUSH  IX
               PUSH  IY
               LD    (callsp),SP
               JP    volaj
sq:            POP   IY
               POP   IX
               RET

ifrutina:      LD    HL,iflevel
               INC   (HL)
               LD    A,(skiplevel)
               AND   A
               RET   NZ

               LD    HL,msname
               PUSH  HL
               CALL  symname
               POP   HL
               LD    (stru),HL
               LD    HL,macn
               LD    (stru+2),HL
               LD    HL,NAMEMAX+3
               LD    (stru+4),HL
               LD    HL,MACEND
               LD    (stru+6),HL
               LD    HL,MACNBR
               LD    (stru+8),HL
               LD    HL,0
               LD    (stru+10),HL
               XOR   A
               RET

value:         PUSH  HL
               LD    HL,0
               ADD   HL,SP
               CALL  constexpr
               POP   HL
               LD    A,H
               OR    L
               RET

ifline:        CALL  inline
               LD    A,(eof)
               AND   A
               RET   NZ

               CALL  match
               DB    T#ifdef
               JR    NZ,if
               CALL  ifrutina
               JR    NZ,ifline
               CALL  search
               JR    NZ,ifline
               LD    A,(iflevel)
               LD    (skiplevel),A
               JR    ifline

if:            CALL  match
               DB    T#if
               JR    NZ,ifn
               LD    HL,iflevel
               INC   (HL)
               LD    A,(skiplevel)
               AND   A
               JR    NZ,ifline      ; uz sa preskakuje
               CALL  value
               JR    NZ,ifline      ; prekladaj
               LD    A,(iflevel)
               LD    (skiplevel),A  ; neprekladaj
               JR    ifline

ifn:           CALL  match
               DB    T#ifndef
               JP    NZ,ife
               CALL  ifrutina
               JR    NZ,ifline
               CALL  search
               JR    Z,ifline
               LD    A,(iflevel)
               LD    (skiplevel),A
               JR    ifline

ife:           CALL  match
               DB    T#else
               JP    NZ,eni1

               LD    A,(iflevel)
               AND   A
               LD    HL,ifline
               PUSH  HL
               JP    Z,noiferr
               LD    A,(skiplevel)
               LD    C,A
               LD    A,(iflevel)
               SUB   C
               JR    NZ,$+6
               LD    (skiplevel),A
               RET

               INC   C
               DEC   C
               RET   NZ
               LD    A,(iflevel)
               LD    (skiplevel),A
               RET

eni1:          CALL  match
               DB    T#elif
               JP    NZ,eni

               LD    A,(iflevel)
               AND   A
               LD    HL,ifline
               PUSH  HL
               JP    Z,noiferr      ; nieje v bloku

               CALL  value
               LD    A,(skiplevel)
               LD    C,A
               LD    A,(iflevel)
               SUB   C
               JR    NZ,els3
               LD    A,H
               OR    L
               JR    Z,els3
               XOR   A              ; vyraz musi byt true
               LD    (skiplevel),A  ; doteraz sa preskakovalo
               RET

els3:          INC   C
               DEC   C
               RET   NZ
               LD    A,(iflevel)    ; od teraz sa bude
               LD    (skiplevel),A
               RET

eni:           CALL  match
               DB    T#ifdeclared
               JR    NZ,enix

               LD    HL,iflevel
               INC   (HL)
               LD    A,(skiplevel)
               AND   A
               JP    NZ,ifline
nextsymb:
               LD    HL,msname
               CALL  symname
               LD    HL,msname
               CALL  findglb
               JR    NZ,isname

nextit:        LD    A,(nch)
               AND   A
               JR    Z,neprek
               LD    A,","
               CALL  matches
               JR    Z,nextsymb
               JR    neprek

isname:        INC   HL
               INC   HL
               INC   HL
               INC   HL
               INC   HL
               BIT   1,(HL)
               JR    NZ,nextit   ; defined
               BIT   2,(HL)
               JP    NZ,ifline   ; used
               JR    nextit

neprek:        LD    A,(iflevel)
               LD    (skiplevel),A
               JP    ifline

enix:          CALL  match
               DB    T#endif
               JP    NZ,ski

               LD    A,(iflevel)
               AND   A
               LD    HL,ifline
               PUSH  HL
               JP    Z,noiferr
               LD    A,(skiplevel)
               LD    C,A
               LD    A,(iflevel)
               SUB   C
               JR    NZ,$+5
               LD    (skiplevel),A
               LD    HL,iflevel
               DEC   (HL)
               RET

ski:           LD    A,(skiplevel)
               AND   A
               JP    NZ,ifline

               LD    A,(ch)
               AND   A
               JP    Z,ifline
               RET

keepch:        PUSH  HL           ; A=znak
               DB    33
pptr:          DW    0           ; nekontroluje pretecenie !!
               INC   HL
               LD    (pptr),HL
               LD    (HL),A
               POP   HL
               RET

preprocess:    LD    A,(ccode)
               AND   A
               JR    Z,nocc

               LD    HL,mline
               LD    (line),HL
               CALL  ifline
               LD    A,(eof)
               AND   A
               RET   NZ
               JR    compr

nocc:          LD    HL,pline
               LD    (line),HL
               JP    inline

compr:         LD    HL,pline-1
               LD    (pptr),HL
               XOR   A
               LD    (subsf),A    ; makra on
               LD    A,(incom)
               AND   A
               JP    NZ,whil19

whil16:        LD    A,(ch)   ; rob pokial nieje koniec riadka
               CP    EOL
               JP    Z,endpre
               CP    T#error  ; error text
               JP    Z,endpre
               CP    T#warning
               JP    Z,Twarn
               CP    T#undef
               JR    NZ,nox1+3
nox1:          LD    (subsf),A
jespace:       CALL  white
               JR    NC,nowhite
               LD    A," "
               CALL  keepch
               CALL  gch
               JR    jespace

nowhite:       CP    "/"
               JR    NZ,tata
               LD    A,(nch)
               CP    "/"
               JP    Z,endpre

tata:          LD    A,(ch)
               CP    34       ; '"'
               JR    NZ,noqu

               CALL  keepch
               CALL  gch
whil17:        LD    A,(ch)
               CP    34
               JR    Z,oksq

               CP    "\"
               JR    NZ,nequ
               LD    A,(nch)
               CP    EOL
               JR    NZ,inquotes
               LD    HL,mline
               LD    (line),HL
               CALL  ifline
               JR    whil17
nequ:
               CP    EOL
               JR    NZ,inquote
               CALL  error
               DM    "no quote"
               NOP
               JP    endpre
inquotes:      CALL  gch       ; \\ atd.
               CALL  keepch
inquote:       CALL  gch       ; kopiruj medzi uvodzovkamy
               CALL  keepch
               JR    whil17
oksq:          CALL  gch
               LD    A,34
               CALL  keepch
               JP    whil16

noqu:          LD    A,(ch)
               CP    "'"      ; '"'
               JR    NZ,noap
               CALL  keepch
               CALL  gch

whil18:        LD    A,(ch)
               CP    "'"
               JR    Z,oksq1
               CP    "\"
               JR    NZ,nequ1
               CALL  gch
               CALL  keepch

nequ1:         LD    A,(ch)
               CP    EOL
               JR    NZ,inapo
               CALL  error
               DM    "no apostrophe"
               NOP
               JP    endpre

inapo:         CALL  gch
               CALL  keepch
               JR    whil18

oksq1:         CALL  gch
               LD    A,"'"
               CALL  keepch
               JP    whil16

noap:          LD    A,(ch)
               CP    "/"
               JR    NZ,noco

               LD    A,(nch)
               CP    "*"
               JR    NZ,noco
               LD    A,2
               LD    (incom),A
               CALL  bump

whil19:        CALL  gch
               CP    EOL
               JP    Z,endpre

hviezda:       CP    "*"
               JR    NZ,whil19
               CALL  gch
               CP    "/"
               JR    NZ,hviezda
               XOR   A
               LD    (incom),A
               JP    whil16

noco:          LD    A,(subsf)
               AND   A
               JP    NZ,znak  ; makra off

               LD    A,(ch)
               CALL  an
               JP    NC,znak
               LD    B,0
               LD    HL,msname

whil20:        LD    A,(ch)
               CALL  an
               JR    NC,endw20

               LD    C,A
               LD    A,B
               CP    NAMEMAX
               JR    NC,endw20

               LD    (HL),C
               INC   HL
               INC   B
               PUSH  HL
               CALL  gch
               POP   HL
               JR    whil20

endw20:        LD    (HL),0
               LD    HL,msname
               LD    (stru),HL
               LD    HL,macn
               LD    (stru+2),HL
               LD    HL,NAMEMAX+3
               LD    (stru+4),HL
               LD    HL,MACEND
               LD    (stru+6),HL
               LD    HL,MACNBR
               LD    (stru+8),HL
               LD    HL,0
               LD    (stru+10),HL
               CALL  search
               JR    Z,recopy

               LD    HL,(cptr)    ; nahradzaj makro
               LD    DE,NAMEMAX
               ADD   HL,DE
               LD    C,(HL)
               INC   HL
               LD    B,(HL)
               INC   HL
               LD    A,(HL)
               BIT   7,A
               JR    Z,reco
               CALL  paramacro
               JR    NZ,reco2       ; bez "()"
               JR    konra

reco2:         LD    A,(BC)
               INC   BC
               CP    "("
               JR    Z,konra
               CALL  keepch
               JR    reco2

reco:          LD    A,(BC)
               INC   BC
               AND   A
               JR    Z,konra
               CALL  keepch
               JR    reco

konra:         LD    A,(ch)
               CALL  an
               JP    NC,whil16
               CALL  gch
               JR    konra+3

recopy:        LD    BC,msname
               LD    A,(BC)
               AND   A
               JP    Z,whil16
               CALL  keepch
               INC   BC
               JR    recopy+3

znak:          CALL  gch
               CALL  keepch
               JP    whil16

endpre:        LD    HL,(pptr)
               LD    BC,pline-1
               CALL  rovna
               JP    Z,preprocess ; prazdny, znova

               LD    BC,pline+LINEMAX
               CALL  rovna
               JR    C,notoo

               CALL  error
               DM    "line too long"
               NOP

notoo:         XOR   A
               CALL  keepch
               CALL  keepch
               LD    HL,pline
               LD    (line),HL
               CALL  bump
               LD    A,(skipline)
               AND   A
               RET   Z
               LD    HL,pline
               LD    A,5
               CALL  zavol
               CALL  TOKENIZUJ
               CALL  OUTPUT
               RET

Twarn:         CALL  gch
               LD    HL,(line)
               LD    A,6
               CALL  zavol
               JP    endpre

; bc=exp stringu
; lptr > (ch)
; vystup na keep() , NZ ak neexpanduje
; a=pocet parametrov
paramacro:     PUSH  BC
               AND   127
               PUSH  AF
               CALL  blanks
               LD    A,(ch)
               CP    "("
               JR    Z,par1
               POP   BC
               POP   BC
               RET

par1:          INC   HL
               XOR   A
               EX    AF,AF'
               LD    BC,macpar
               LD    A,(HL)
               INC   HL
               CP    ")"
               JR    Z,par2
               DEC   HL

par3:          CALL  setpa
par4:          LD    A,(HL)
               CP    ")"
               JR    Z,par5
               CP    ","
               JR    Z,par5
               AND   A
               JR    Z,errmac
               INC   HL
               JR    par4
par5:          LD    (HL),0
               INC   HL
               CP    ","
               JR    Z,par3

par2:          LD    (lptr),HL
               LD    A,(HL)
               LD    (ch),A

               POP   BC
               EX    AF,AF'
               CP    B     ;kontrola poctu parametrov
               LD    (maxpar),A
               CALL  NZ,badarg
               LD    HL,(lptr)
               EX    (SP),HL
               CALL  expandmac   ; hl>image
               POP   HL
restor:        LD    (lptr),HL
               LD    A,(HL)
               LD    (ch),A
               CP    A
               RET

expandmac:     CALL  restor
ilo:           LD    A,(ch)
               AND   A
               RET   Z      ; rob pokial nieje NULL
               CALL  alpha
               JR    C,zn
               CALL  gch
               CALL  keepch
               JR    ilo

zn:            LD    HL,msname
               PUSH  HL
               CALL  symname
               POP   HL
               CP    2             ;je to premenna ?
               CALL  C,parameter   ;dosad parameter ak je mozne

               LD    A,(HL)
               AND   A
               JR    Z,ilo
               INC   HL
               CALL  keepch
               JR    $-8

errmac:        CALL  error
               DM    "unexpected EOL"
               NOP
               JP    abort

setpa:         EX    AF,AF'
               INC   A
               EX    AF,AF'
               LD    A,L
               LD    (BC),A
               INC   BC
               LD    A,H
               LD    (BC),A
               INC   BC
               RET

parameter:     LD    A,(HL)
               SUB   "a"
               DB    &FE
maxpar:        NOP
               RET   NC
               ADD   A
               LD    HL,macpar
               LD    E,A
               LD    D,0
               ADD   HL,DE
               JP    hlhl

noiferr:       CALL  error
               DM    "no matching #if..."
               DB    0
               XOR   A
               LD    (errflag),A
               RET

submac:        LD    HL,msname
               CALL  symname
               JR    C,jemak1
               CALL  illname
               JP    kill

jemak1:        LD    HL,msname
               LD    (stru),HL
               LD    HL,macn
               LD    (stru+2),HL
               LD    HL,NAMEMAX+3
               LD    (stru+4),HL
               LD    HL,MACEND
               LD    (stru+6),HL
               LD    HL,MACNBR
               LD    (stru+8),HL
               LD    HL,0
               LD    (stru+10),HL
               CALL  search
               JP    Z,kill

               LD    HL,(cptr)
               LD    B,NAMEMAX+3
               LD    (HL),0
               INC   HL
               DJNZ  $-3
               LD    HL,makier
               DEC   (HL)
               JP    kill

addsvmac:      LD    HL,sam_vision
               PUSH  HL
               LD    (stru),HL
               LD    HL,macn
               LD    (stru+2),HL
               LD    HL,NAMEMAX+3
               LD    (stru+4),HL
               LD    HL,MACEND
               LD    (stru+6),HL
               LD    HL,MACNBR
               LD    (stru+8),HL
               LD    HL,0
               LD    (stru+10),HL
               CALL  search
               LD    DE,(cptr)
               POP   HL
               PUSH  HL
               PUSH  DE
               LD    BC,11    ; copy to cptr
               LDIR
               POP   HL
               LD    DE,NAMESIZE
               ADD   HL,DE
               LD    DE,(macptr)
               LD    (HL),E   ; cptr+NAME = macptr
               INC   HL
               LD    (HL),D
               LD    DE,macq  ; copy to macq
               POP   HL
               LD    BC,11
               LD    (macptr),BC
               LDIR
               RET

addmac:        LD    HL,msname
               CALL  symname
               JR    C,jemak
               CALL  illname
               JP    kill

jemak:         LD    HL,(lptr)
               LD    B,0
               LD    A,(HL)
               CP    "("
               JR    NZ,hj
               SET   7,B            ; nastav bit "with param"
hjx:           LD    A,(HL)
               INC   HL
               CALL  lower     ; a..z
               JR    NC,$+3
               INC   B         ; param ++
               CP    ")"
               JR    NZ,hjx
hj:            LD    (lptr),HL
               LD    A,B
               LD    (macflag),A
               LD    HL,msname
               LD    (stru),HL
               LD    HL,macn
               LD    (stru+2),HL
               LD    HL,NAMEMAX+3
               LD    (stru+4),HL
               LD    HL,MACEND
               LD    (stru+6),HL
               LD    HL,MACNBR
               LD    (stru+8),HL
               LD    HL,0
               LD    (stru+10),HL
               CALL  search
               JR    NZ,defin2

               LD    HL,(cptr)
               LD    (cptr2),HL
               LD    A,H
               OR    L
               JR    NZ,defim

               CALL  error
               DM    "macro name table full"
               NOP
               RET

defim:         LD    HL,msname
               LD    DE,(cptr2)

defin1:        LD    A,(HL)
               LDI
               AND   A
               JR    NZ,defin1
               LD    HL,makier
               INC   (HL)

defin2:        LD    HL,(cptr)
               LD    DE,NAMEMAX
               ADD   HL,DE
               LD    BC,(macptr)
               EX    DE,HL
               LD    HL,macq
               ADD   HL,BC
               EX    DE,HL

               LD    (HL),E
               INC   HL
               LD    (HL),D
               INC   HL
               DB    62
macflag:       NOP
               LD    (HL),A

ysw:           CALL  white
               JR    NC,xsw
               CALL  gch
               JR    ysw

xsw:           CALL  gch
               CP    "\"
               JR    NZ,xsw2
               LD    A,(ch)
               AND   A
               JR    NZ,xsw2
               CALL  ifline
               JR    xsw

xsw2:          CALL  putmac

               CP    " "        ; aj medzera
               JR    NC,xsw

               LD    HL,(macptr)
               LD    DE,MACMAX
               SBC   HL,DE
               RET   C
               CALL  error
               DM    "macro string queue full"
               NOP
               JP    abort

putmac:        LD    HL,macq        ; CY=1 & macptr++ if OK
               LD    DE,(macptr)
               ADD   HL,DE
               LD    (HL),A
               INC   DE
               LD    (macptr),DE
               RET

find:          LD    ($+4),A ; hlada token A
               LD    A,0
               CALL  matches
               RET   Z
               CALL  preskoc
               CALL  endst
               RET   NZ
               JR    find+3

search:        LD    HL,(stru) ; vracia 0 alebo 1 / z, nz
               CALL  hash
               LD    DE,(stru+8)
               DEC   DE
               CALL  CCUDIV

               LD    HL,(stru+4)
               CALL  CCUMUL

               LD    DE,(stru+2)
               ADD   HL,DE
               LD    (cptr),HL
               LD    (cptr2),HL

whil:          LD    HL,(cptr)     ; prazdny slot ?
               LD    A,(HL)
               AND   A             ; ano
               RET   Z

               LD    DE,(stru+10)
               ADD   HL,DE         ; plus offset name
               LD    B,NAMESIZE
               LD    DE,(stru)     ; ssname
               CALL  astreq
               RET   NZ            ; nasiel, vrat 1

               LD    HL,(cptr)
               LD    DE,(stru+4)
               ADD   HL,DE
               LD    (cptr),HL      ; HL=next polozka

               LD    DE,(stru+6)    ; koniec tabulky ?
               SBC   HL,DE
               ADD   HL,DE
               JR    C,intab

               LD    HL,(stru+2)   ; ano, na zaciatok
               LD    (cptr),HL

intab:         LD    DE,(cptr2)    ; bola uz cela tabulka ?
               AND   A
               SBC   HL,DE
               JR    NZ,whil       ; nie, este raz

               LD    HL,0          ; cptr=NULL
               LD    (cptr),HL
               XOR   A
               RET

hash:          PUSH  HL
               EX    (SP),IX
               LD    HL,1973
               LD    D,0

hash1:         LD    A,(IX+0)
               AND   A
               JR    NZ,$+5
               POP   IX
               RET

               LD    E,A
               ADD   HL,DE
               ADD   HL,HL
               ADD   HL,DE
               INC   IX
               JR    hash1

setstage:      LD    (za+1),HL       ; HL= &before
               LD    (za1+1),DE      ; DE= &start

               LD    HL,(stagenext)
za:            LD    (0),HL

               LD    A,H
               OR    L
               JR    NZ,za1

               LD    HL,stage
               LD    (stagenext),HL

za1:           LD    (0),HL
               RET

clearstage:    LD    BC,(stagenext)   ; HL = before
               LD    A,B
               OR    C
               LD    A,0              ; de = start

               JR    Z,$+3
               LD    (BC),A

               LD    (stagenext),HL
               LD    A,H
               OR    L
               RET   NZ
               EX    DE,HL
               LD    A,H
               OR    L
               JP    NZ,peephole
               RET

outdec:        BIT   7,H
               JR    Z,outdec1
               LD    A,"-"
               PUSH  HL
               CALL  outbyte
               POP   HL
               CALL  CCNEG

outdec1:       LD    DE,10000      ; HL = cislo
               LD    C,0
               CALL  outu
               LD    DE,1000
               CALL  outu
               LD    DE,100
               CALL  outu
               LD    DE,10
               CALL  outu
               LD    A,L
               ADD   "0"
               JP    outbyte

outu:          LD    A,"0"-1
               INC   A
               AND   A
               SBC   HL,DE
               JR    NC,outu+2
               ADD   HL,DE
               CP    "0"
               JR    NZ,nonz
               LD    A,C
               AND   A
               RET   Z
               JR    nonz+2

nonz:          LD    C,"0"
               PUSH  BC
               PUSH  HL
               CALL  outbyte
               POP   HL
               POP   BC
               RET

ostr:          EX    (SP),HL
               CALL  ol
               INC   HL
               EX    (SP),HL
               RET

ol:            CALL  ot
               JP    nl

ot:            LD    A,(HL)
               CP    " "
               RET   C
               PUSH  HL
               CALL  outbyte
               POP   HL
               INC   HL
               JR    ot

os:            LD    A,(HL)
               AND   A
               RET   Z
               PUSH  HL
               CALL  outbyte
               POP   HL
               INC   HL
               JR    os

nl:            PUSH  HL
               LD    A,13
               CALL  outbyte
               POP   HL
               RET

col:           LD    A,":"

outbyte:       LD    HL,(stagenext)
               LD    C,A
               LD    A,H
               OR    L
               LD    A,C
               JR    Z,priamo1

               LD    (HL),A
               INC   HL
               LD    (stagenext),HL
               AND   A
               RET

priamo1:       CP    13
               DB    33
p_place:       DW    place
               LD    (HL),A
               INC   HL
               LD    (p_place),HL
               RET   NZ

               LD    HL,place
               LD    (p_place),HL
               CALL  OUTBUF
               OR    H
               AND   A
               RET

warning:       LD    B,4
               JR    error+2
error:         LD    B,2
               LD    A,(errflag)
               AND   A
               JR    NZ,skip      ; jr nz,skip

               INC   A
               LD    (errflag),A
               LD    HL,errors
               INC   (HL)

               POP   HL
               PUSH  HL
               PUSH  IY
               PUSH  IX
               CALL  enterr
               POP   IX
               POP   IY

skip:          EX    (SP),HL       ; preskoc hlasenie
               LD    A,(HL)
               AND   A
               INC   HL
               JR    NZ,skip+1
               EX    (SP),HL
               RET

enterr:        LD    DE,errr
               LD    (loopv),DE
               LD    (callsp),SP

               SET   7,H
               LD    DE,(sourcx+1)
               LD    A,(sourcx)
               LD    C,A          ; hl =error string
               LD    A,(input2)
               EX    AF,AF'       ; input 2 = af'

               LD    A,B          ; CDE=source file
               JP    volaj

errr:                            ; a=posun
               EX    AF,AF'
               LD    A,(input2)
               CP    EOF
               RET   NZ

               LD    HL,(source+1)
               EX    AF,AF'
               LD    E,A
               LD    D,0
               ADD   HL,DE
               LD    (source+1),HL ; uprav zdrojovy ukazatel
               RET

streq:         LD    B,0      ; HL = str1
               LD    A,(DE)   ; DE = str2
               AND   A
               JR    Z,ala
               INC   B
               XOR   (HL)
               INC   HL
               INC   DE
               JR    Z,streq+2
noo:           XOR   A
               RET          ; Z= 1 if not found

ala:           LD    A,B
               AND   A
               RET

astreq:        LD    C,0        ; HL=str1
               LD    A,(DE)     ; DE=str2
               XOR   (HL)       ; B =dlzka symbolu
               JR    NZ,tess
               LD    A,(HL)
               CP    " "
               JR    C,tess
               INC   HL
               INC   DE
               INC   C
               DJNZ  astreq+2

tess:          LD    A,(HL)
               CALL  an
               JR    C,noo
               LD    A,(DE)
               CALL  an
               JR    C,noo
               LD    A,C
               AND   A
               RET

match:         CALL  blanks     ; z=1 ak nasiel
               EX    (SP),HL
               CP    (HL)
               INC   HL
               EX    (SP),HL

match2:        RET   NZ
               INC   HL
               CALL  cbum1
               XOR   A
               RET

matches:       PUSH  AF
               CALL  blanks
               POP   BC
               CP    B
               JR    match2

blanks:        LD    A,(ch)
               AND   A
               JP    Z,novy

               LD    C,A
               DB    33
lptr:          DW    0
               LD    A,(HL)
               AND   A
               RET   Z
               CP    "!"
               RET   NC

               LD    A,C         ; vracia A
               PUSH  AF
               LD    A,1
               CALL  bump
               POP   AF

               JP    blanks

novy:          LD    HL,mline
               LD    DE,(line)
               AND   A
               SBC   HL,DE
               RET   Z

               CALL  preprocess
               LD    A,(eof)
               AND   A
               JR    Z,blanks
               RET

;---------------------------------------------------------------
nextop:        PUSH  HL               ; HL = list of operator
               XOR   A                ; vracia 0/1
               LD    (opindex),A
               CALL  blanks
               POP   HL
konu:          LD    A,(HL)
               AND   A
               JP    Z,nula           ; zero ak koniec opstr
               PUSH  HL
               LD    HL,(lptr)
               SUB   (HL)
               POP   HL
                                     ; skok ak nieje operand
               JP    Z,jedna
nejeop:        LD    A,(opindex)
               INC   A
               LD    (opindex),A
               INC   HL
               JR    konu

skim:          LD    HL,-20       ; hl = struktura
               ADD   HL,SP
               LD    SP,HL
               PUSH  HL
               EX    (SP),IX
               LD    BC,6*2
               EX    DE,HL
               LD    HL,myst
               LDIR

               LD    (IX+14),0

whil28:        LD    L,(IX+8)
               LD    H,(IX+9)
               LD    E,(IX+10)
               LD    D,(IX+11)
               CALL  plnge1
               LD    (IX+12),L
               LD    (IX+13),H
               LD    L,(IX+0)
               LD    H,(IX+1)
               CALL  nextop
               JR    Z,g1

               LD    A,1
               CALL  bump
               LD    A,(IX+14)
               AND   A
               JR    NZ,g3

               INC   (IX+14)
               CALL  getlabel
               LD    (IX+16),L
               LD    (IX+17),H

g3:            LD    A,(IX+12)
               OR    (IX+13)
               LD    L,(IX+2)
               LD    H,(IX+3)
               LD    E,(IX+16)
               LD    D,(IX+17)
               LD    C,(IX+10)
               LD    B,(IX+11)
               CALL  dropout
               JR    whil28

g1:            LD    A,(IX+14)      ; (hits)
               AND   A
               JR    Z,g2

               LD    A,(IX+12)
               OR    (IX+13)
               LD    L,(IX+2)
               LD    H,(IX+3)
               LD    E,(IX+16)
               LD    D,(IX+17)
               LD    C,(IX+10)
               LD    B,(IX+11)
               CALL  dropout

               LD    L,(IX+6)
               LD    H,(IX+7)
               CALL  const

               CALL  getlabel
               PUSH  HL
               CALL  jump

               LD    L,(IX+16)
               LD    H,(IX+17)
               CALL  postlabel

               LD    L,(IX+4)
               LD    H,(IX+5)
               CALL  const

               POP   HL
               CALL  postlabel

               XOR   A
               LD    L,(IX+10)
               LD    H,(IX+11)
               PUSH  HL
               POP   IX

               LD    (IX+2),A
               LD    (IX+4),A
               LD    (IX+6),A
               LD    (IX+7),A
               LD    (IX+14),A
               LD    (IX+15),A

               LD    DE,0
               JR    nulax

g2:            LD    E,(IX+12)
               LD    D,(IX+13)

nulax:         POP   IX
               LD    HL,20
               ADD   HL,SP
               LD    SP,HL
               EX    DE,HL
               LD    A,H
               OR    L
               RET

dropout:       AND   A              ; a=k
               PUSH  BC             ; hl=func
               EX    (SP),IX        ; de=exit1
               LD    (drop1+2),HL   ; bc=lval
               PUSH  DE             ; vracia hl
               JR    Z,nulv
               PUSH  BC
               POP   HL
               CALL  rvalue
               JR    drop1

nulv:          LD    A,(IX+6)
               AND   A
               LD    L,(IX+8)    ; if 1 do const
               LD    H,(IX+9)
               CALL  NZ,const

drop1:         POP   HL
               CALL  0
               POP   IX
               RET

plnge:         LD    (wse+1),HL  ;hl, af, de, bc
               LD    HL,-18
               ADD   HL,SP
               LD    SP,HL
               PUSH  BC
               PUSH  DE
               PUSH  AF
wse:           LD    HL,0
               PUSH  HL

               LD    HL,0
               ADD   HL,SP
               PUSH  HL
               EX    (SP),IX

               EX    DE,HL
               LD    D,B
               LD    E,C
               CALL  plnge1

               LD    (IX+8),L
               LD    (IX+9),H  ;k=plnge1(heir,lval)

               LD    L,(IX+0)
               LD    H,(IX+1)
               CALL  nextop

               LD    E,(IX+8)
               LD    D,(IX+9)
               JP    Z,endplnge
               LD    A,D
               OR    E
               LD    L,(IX+6)
               LD    H,(IX+7)
               CALL  NZ,rvalue

whil26:        LD    L,(IX+0)    ; rob rovnake operacie
               LD    H,(IX+1)
               CALL  nextop
               LD    DE,0
               JR    Z,endplnge

               CALL  preskoc

               LD    A,(opindex)
               ADD   (IX+3)
               LD    (opindex),A
               ADD   A
               LD    E,A
               LD    D,0
               LD    HL,op
               ADD   HL,DE
               CALL  hlhl
               LD    (pstruct),HL
               LD    HL,op2
               ADD   HL,DE
               CALL  hlhl
               LD    (pstruct+2),HL
               LD    L,(IX+4)
               LD    H,(IX+5)
               LD    (pstruct+4),HL
               LD    L,(IX+6)
               LD    H,(IX+7)
               LD    (pstruct+6),HL
               LD    HL,10+2
               ADD   HL,SP
               LD    (pstruct+8),HL
               CALL  plnge2
               JR    whil26

endplnge:      POP   IX        ; DE=vysledok
               LD    HL,26
               ADD   HL,SP
               LD    SP,HL
               LD    A,D
               OR    E
               EX    DE,HL     ; Z,NZ, in HL
               RET

plnge1:        LD    (fun_+1),HL  ; hl=heir
               LD    (hodno+1),DE ; de=lval
               PUSH  HL
               PUSH  HL
               PUSH  HL
               LD    HL,0
               ADD   HL,SP
               LD    D,H
               LD    E,L
               INC   DE
               INC   DE
               CALL  setstage

hodno:         LD    HL,0
               PUSH  HL
fun_:          CALL  0

               EX    DE,HL
               LD    HL,6
               ADD   HL,SP
               LD    (HL),E
               INC   HL
               LD    (HL),D
               EX    (SP),IX
               LD    A,(IX+6)
               AND   A
               POP   IX
               POP   HL

               LD    DE,0
               CALL  NZ,clearstage  ;clear if constant
               POP   BC
               POP   HL
               LD    A,H
               OR    L
               RET             ; HL = vysledok heir


plnge2:        LD    HL,-14
               ADD   HL,SP
               LD    SP,HL

               LD    DE,pstruct
               EX    DE,HL
               LD    BC,10
               LDIR          ; kopiruj parametre
               LD    H,D
               LD    L,E
               INC   DE
               INC   DE
               CALL  setstage

               LD    HL,6
               ADD   HL,SP
               LD    E,(HL)
               INC   HL
               LD    D,(HL)
               PUSH  DE
               EX    (SP),IX
               LD    (IX+10),1
               LD    (IX+14),0
               LD    (IX+15),0
               LD    A,(IX+6)
               AND   A
               POP   IX
               JR    Z,d6

               LD    HL,0
               ADD   HL,SP
               PUSH  HL
               EX    (SP),IX
               LD    L,(IX+4)
               LD    H,(IX+5)
               LD    E,(IX+8)
               LD    D,(IX+9)
               PUSH  DE
               CALL  plnge1
               POP   HL
               CALL  NZ,rvalue
               LD    L,(IX+6)
               LD    H,(IX+7)
               LD    DE,2*4
               ADD   HL,DE
               LD    A,(HL)
               INC   HL
               OR    (HL)
               LD    E,5
               JR    NZ,d1x
               ADD   HL,DE      ; hl=&lval[7]
               LD    DE,(stagenext)
               LD    (HL),E
               INC   HL
               LD    (HL),D     ; lval[7]=stagenext
d1x:           LD    C,(IX+0)
               LD    B,(IX+1)
               LD    E,(IX+8)
               LD    D,(IX+9)
               LD    L,(IX+6)
               LD    H,(IX+7)
               PUSH  HL
               CALL  dbltest
               POP   HL
               LD    DE,4*2
               ADD   HL,DE
               LD    E,(HL)
               INC   HL
               LD    D,(HL)
               EX    DE,HL
               CALL  dosize ;hl=lval[4]<<dbltest (oper,lval2,lval
               CALL  const2
               JP    d7

d6:            CALL  pushr
               LD    HL,0
               ADD   HL,SP
               PUSH  HL
               EX    (SP),IX
               LD    L,(IX+4)
               LD    H,(IX+5)
               LD    E,(IX+8)
               LD    D,(IX+9)
               PUSH  DE
               CALL  plnge1
               POP   HL
               CALL  NZ,rvalue
               LD    L,(IX+8)
               LD    H,(IX+9)
               LD    DE,2*3
               ADD   HL,DE
               LD    A,(HL)
               INC   HL
               INC   HL      ;lval2 [3]
               AND   A
               JP    Z,d8

               LD    A,(HL)  ; konstanta
               INC   HL
               OR    (HL)
               JR    NZ,d2x

               LD    E,5
               ADD   HL,DE      ; hl= &lval2 [7]
               LD    E,(IX+12)
               LD    D,(IX+13)
               LD    (HL),E
               INC   HL
               LD    (HL),D     ; lval2 [7]=start

d2x:           LD    L,(IX+0)
               LD    H,(IX+1)
               LD    BC,ffsub
               CALL  rovna
               SCF
               CCF
               JR    Z,d3x
               LD    BC,ffadd
               CALL  rovna
               JR    NZ,d9
               SCF

d3x:           LD    HL,(csp)   ; scf pre add
               INC   HL
               INC   HL
               LD    (csp),HL
               PUSH  AF
               LD    L,(IX+10)
               LD    H,(IX+11)
               LD    DE,0
               CALL  clearstage
               LD    C,(IX+0)
               LD    B,(IX+1)
               LD    E,(IX+6)
               LD    D,(IX+7)
               LD    L,(IX+8)
               LD    H,(IX+9)
               PUSH  HL
               CALL  dbltest
               POP   HL
               LD    C,A
               LD    DE,4*2
               ADD   HL,DE
               LD    E,(HL)
               INC   HL
               LD    D,(HL)
               EX    DE,HL
               POP   AF
               JR    C,scit

               LD    DE,0
               EX    DE,HL
               SBC   HL,DE
scit:          LD    A,C
               CALL  dosize   ;lval2[4]<<dbltest (oper,lval,lv2
               CALL  const2
               LD    HL,ffadd
               LD    (IX+0),L      ; uprav sub rutinu
               LD    (IX+1),H
               LD    (IX+2),L
               LD    (IX+3),H
               JP    d7

d9:            LD    C,(IX+0)
               LD    B,(IX+1)
               LD    E,(IX+6)
               LD    D,(IX+7)
               LD    L,(IX+8)
               LD    H,(IX+9)
               PUSH  HL
               CALL  dbltest
               POP   HL
               PUSH  HL
               LD    DE,4*2
               ADD   HL,DE
               LD    E,(HL)
               INC   HL
               LD    D,(HL)
               EX    DE,HL
               CALL  dosize ;hl=lval2[4]<<dbltest (oper,lval,lv2
               CALL  const
               POP   HL
               LD    E,(IX+12)
               LD    D,(IX+13)
               CALL  smartpop
               JP    d7

d8:            LD    L,(IX+8)
               LD    H,(IX+9)
               LD    E,(IX+12)
               LD    D,(IX+13)
               CALL  smartpop
               LD    C,(IX+0)
               LD    B,(IX+1)
               LD    E,(IX+6)
               LD    D,(IX+7)
               LD    L,(IX+8)
               LD    H,(IX+9)
               PUSH  BC
               PUSH  DE
               PUSH  HL
               CALL  dbltest
               CALL  mreg
               POP   DE
               POP   HL
               POP   BC
               CALL  dbltest
               CP    1
               JR    Z,d7

               PUSH  AF
               CALL  swap
               POP   AF
               CALL  mreg
               LD    BC,ffsub
               LD    L,(IX+0)
               LD    H,(IX+1)
               CALL  rovna
               CALL  Z,swap

d7:            LD    A,(IX+0)
               OR    (IX+1)    ; oper
               JP    Z,d10

               LD    L,(IX+6)   ; lval, lval2
               LD    H,(IX+7)
               LD    E,(IX+8)
               LD    D,(IX+9)

               LD    BC,3*2
               ADD   HL,BC
               EX    DE,HL
               ADD   HL,BC

               LD    A,(DE)     ; su obe konstanty ?
               AND   (HL)
               LD    (DE),A     ; lval[3] = lval[3] & lval2[3]
               JR    Z,d13

               INC   DE         ; ak ide o konstanty
               INC   DE
               PUSH  DE         ; DE = &lval[4]
               INC   HL
               INC   HL

               LD    C,(HL)
               INC   HL
               LD    B,(HL)
               EX    DE,HL
               LD    E,(HL)
               INC   HL
               LD    D,(HL)
               EX    DE,HL     ;bc=lval2, hl=lval
               LD    E,C
               LD    D,B
               LD    C,(IX+0)
               LD    B,(IX+1)
               CALL  calc       ; vypocitaj rovno vysledok
               POP   DE
               EX    DE,HL
               LD    (HL),E     ; a uloz do lval [4]
               INC   HL
               LD    (HL),D
               INC   HL
               LD    (HL),0    ; lval [5] =0
               LD    L,(IX+10) ; a posli to von
               LD    H,(IX+11)
               LD    DE,0
               CALL  clearstage
               JR    d12

d13:           CALL  isvoidfnc  ; hl lval; de lval2
               CALL  mismas
               CALL  isunsign   ; testuje 7 bajt lval
               LD    L,(IX+0)   ; signed operation
               LD    H,(IX+1)
               JR    Z,d14
               LD    L,(IX+2)   ; unsigned operation
               LD    H,(IX+3)
d14:           PUSH  HL
               CALL  jphl
               POP   DE         ; lval [6] = oper
               LD    L,(IX+6)
               LD    H,(IX+7)
               LD    BC,6*2
               ADD   HL,BC
               LD    (HL),E
               INC   HL
               LD    (HL),D

d12:           LD    BC,ffsub
               LD    L,(IX+0)
               LD    H,(IX+1)
               CALL  rovna
               JR    NZ,d11

               LD    L,(IX+6)   ; lval, lval2
               LD    H,(IX+7)
               LD    E,(IX+8)
               LD    D,(IX+9)

               LD    BC,4
               ADD   HL,BC
               EX    DE,HL
               ADD   HL,BC

               LD    A,(HL)   ;lval=CINT & lval2 = CINT
               SBC   HL,BC
               AND   %10001000
               LD    C,A
               LD    A,(DE)
               AND   %10001000
               CP    C
               JR    NZ,d11
               AND   A
               JR    Z,d11    ; variable only

               PUSH  HL        ; if pointer to struct or int
               CALL  swap
               EX    (SP),IX
               CALL  skipsize
               CP    2
               JR    NZ,d111
               LD    HL,1      ; to int
               CALL  const
               CALL  ffasr
               POP   IX
               JR    d11
d111:          CALL  const     ; to struct
               CALL  ffdiv
               POP   IX

d11:           LD    L,(IX+0)
               LD    H,(IX+1)
               LD    BC,ffsub
               CALL  rovna
               JR    Z,doswa
               LD    BC,ffadd
               CALL  rovna
               JR    NZ,d10
doswa:         LD    L,(IX+6)
               LD    H,(IX+7)
               LD    E,(IX+8)
               LD    D,(IX+9)
               CALL  result

d10:           LD    HL,14      ; end of plnge2
               POP   IX
               ADD   HL,SP
               LD    SP,HL
               RET

jphl:          JP    (HL)

dosize:        CP    1
               RET   Z
               LD    E,A
               LD    D,0
               JP    CCMUL      ; void vrati 0 !!!!!!!!!!!!!!

isvoidfnc:     LD    L,(IX+6)   ; lval, lval2
               LD    H,(IX+7)   ; test na void
               LD    E,(IX+8)
               LD    D,(IX+9)
               PUSH  HL
               PUSH  DE
               CALL  hlhl
               INC   HL
               LD    C,(HL)
               EX    DE,HL
               CALL  hlhl
               INC   HL
               LD    A,(HL)
               CP    CVOID
               JR    Z,posudv
               LD    A,C
               CP    CVOID
               JR    Z,posudv
posu:          POP   DE
               POP   HL
               RET

posudv:        CALL  warning
               DM    "void in expression"
               NOP
               JR    posu

mismas:        PUSH  HL
               PUSH  DE
               LD    A,D
               OR    E
               JR    Z,posu
               LD    A,H
               OR    L
               JR    Z,posu
               LD    BC,4
               ADD   HL,BC
               EX    DE,HL
               ADD   HL,BC
               LD    A,(DE)
               AND   A
               JR    Z,posu
               LD    A,(HL)
               AND   A
               JR    Z,posu
               LD    A,(DE)
               XOR   (HL)
               JR    Z,posu
               CALL  warning
               DM    "pointer type mismatch"
               NOP
               JR    posu

isunsign:      LD    BC,7
               ADD   HL,BC
               EX    DE,HL
               ADD   HL,BC
               LD    A,(DE)
               OR    (HL)    ; 1 ak unsigned
               RET

calc:          PUSH  HL      ; HL = left
               PUSH  DE      ; BC = oper
               LD    H,B     ; DE = right
               LD    L,C
               PUSH  IX      ; HL = vracia vysledok operacie
               LD    IX,opera1
calc10:        LD    C,(IX+0)
               LD    B,(IX+1)
               LD    A,B
               OR    C
               JR    Z,endcalc
               CALL  rovna
               LD    C,(IX+2)
               LD    B,(IX+3)
               INC   IX
               INC   IX
               INC   IX
               INC   IX
               JR    NZ,calc10
               POP   IX
               POP   DE
               POP   HL
               EX    DE,HL
               PUSH  BC     ; nepriamy skok na rutinu
               RET
endcalc:       POP   IX
               POP   HL
               POP   HL
               LD    HL,0
               RET

CCADD:         ADD   HL,DE
               RET

CCMOD:         CALL  CCDIV
               EX    DE,HL
               RET

expression:    PUSH  DE            ; hl =&const
               PUSH  HL            ; de =&value
               LD    HL,-16
               ADD   HL,SP
               LD    SP,HL
               PUSH  HL
               CALL  heir1         ; hl=lval
               LD    A,H
               OR    L

               POP   HL
               PUSH  HL
               CALL  NZ,rvalue

               EX    (SP),IX
               LD    A,(IX+6)
               LD    L,(IX+16)
               LD    H,(IX+17)
               LD    (HL),A
               INC   HL
               LD    (HL),0
               LD    E,(IX+8)
               LD    D,(IX+9)
               LD    L,(IX+18)
               LD    H,(IX+19)
               LD    (HL),E
               INC   HL
               LD    (HL),D
               POP   IX
               LD    HL,16+4
               ADD   HL,SP
               LD    SP,HL
               RET

heir1:         EX    DE,HL    ; HL = lval[]
                                  ; oper2        22
               LD    HL,-22        ; lval2        6
               ADD   HL,SP         ; oper         4
               LD    SP,HL         ; k            2
               PUSH  DE            ; lval         0
                                  ; sp=sp-24
               LD    HL,heir2
               CALL  plnge1
               POP   DE
               POP   BC
               PUSH  HL
               PUSH  DE

               EX    (SP),IX
               LD    A,(IX+6)
               AND   A
               LD    L,(IX+8)
               LD    H,(IX+9)
               CALL  NZ,const
               EX    (SP),IX

               LD    A,"="
               CALL  matches
               LD    DE,0
               PUSH  DE
               JR    Z,vyho1
               POP   DE
               SUB   To+38       ; "|="
               JR    C,okto
               CP    10
               JR    C,okto1

okto:          POP   DE          ; lval
               POP   DE          ; k
               LD    HL,20
               ADD   HL,SP
               LD    SP,HL
               EX    DE,HL
               LD    A,H
               OR    L
               RET           ; return k;
okto1:
               PUSH  AF
               CALL  preskoc
               POP   AF
               ADD   A
               LD    L,A
               EX    AF,AF'
               LD    H,0
               LD    DE,operandy
               ADD   HL,DE
               LD    A,(HL)
               INC   HL
               LD    H,(HL)
               LD    L,A
               PUSH  HL

               EX    AF,AF'
               LD    L,A
               LD    H,0
               LD    DE,operandx
               ADD   HL,DE
               LD    A,(HL)
               INC   HL
               LD    H,(HL)
               LD    L,A
               EX    DE,HL

vyho1:         LD    HL,22+2
               ADD   HL,SP
               LD    (HL),E
               INC   HL
               LD    (HL),D  ; oper2=DE
               POP   HL

               POP   BC      ; oper=HL
               POP   DE
               POP   AF
               PUSH  HL
               PUSH  DE
               PUSH  BC

               LD    A,D
               OR    E
               JR    NZ,dx
               CALL  needlval
               POP   HL
               JR    d55

dx:            EX    (SP),IX
               LD    A,(IX+2)
               AND   A
               EX    (SP),IX
               JR    Z,d2      ; hl=oper

               LD    A,H
               OR    L
               JR    Z,d3
               CALL  pushr
               POP   HL
               PUSH  HL
               CALL  rvalue

d3:            CALL  plngs
               POP   BC
               POP   DE
               POP   HL
               PUSH  HL
               PUSH  DE
               PUSH  BC
               LD    A,H
               OR    L
               CALL  NZ,popr
               JR    d5

d2:            LD    A,H
               OR    L
               JR    Z,d4
               POP   HL
               PUSH  HL
               CALL  rvalue
               CALL  plngs
               JR    d5

d4:            LD    HL,6
               ADD   HL,SP
               PUSH  HL
               CALL  heir1
               POP   HL
               PUSH  HL          ; hl=lval2
               CALL  NZ,rvalue
               EX    (SP),IX
               LD    A,(IX+10)   ; hl=lval2[5]
               POP   IX
               POP   HL
               PUSH  HL          ; hl=&lval[5]
               LD    BC,2*5
               ADD   HL,BC
               LD    (HL),A
d5:            POP   HL
               CALL  store

d55:           LD    HL,22
               ADD   HL,SP
               LD    SP,HL
               JP    nula

plngs:         POP   AF
               POP   HL
               POP   DE
               POP   BC
               PUSH  BC
               PUSH  DE
               PUSH  HL
               PUSH  AF
               LD    (pstruct+6),HL ; hl=lval
               LD    (pstruct),BC
               LD    HL,22+2
               ADD   HL,SP
               LD    C,(HL)
               INC   HL
               LD    B,(HL)
               LD    (pstruct+2),BC  ; oper2
               LD    HL,heir1
               LD    (pstruct+4),HL
               LD    HL,6+2
               ADD   HL,SP
               LD    (pstruct+8),HL
               JP    plnge2

vycisli:       LD    A,(IX+2)
               OR    (IX+3)
               LD    L,(IX+4)
               LD    H,(IX+5)
               JP    NZ,rvalue
               LD    DE,6
               ADD   HL,DE
               LD    A,(HL)
               INC   HL
               INC   HL
               AND   A
               RET   Z
               CALL  hlhl
               JP    const

heir2:         PUSH  HL             ; lval
               PUSH  HL             ; k
               PUSH  HL
               LD    HL,0
               ADD   HL,SP
               PUSH  HL
               EX    (SP),IX
               LD    E,(IX+4)
               LD    D,(IX+5)
               LD    HL,heir3
               CALL  plnge1
               LD    (IX+2),L
               LD    (IX+3),H  ;k=plnge1(heir3,lval)
               LD    HL,he2
               CALL  nextop
               JR    NZ,ister
eter:          POP   IX
               POP   HL
               POP   HL
               POP   BC
               LD    A,H
               OR    L
               RET

ister:         LD    A,"?"
               CALL  needtoken
               CALL  vycisli
               CALL  getlabel
               LD    (IX+0),L
               LD    (IX+1),H
               CALL  ne0
               CALL  getlabel
               LD    E,(IX+4)
               LD    D,(IX+5)
               LD    HL,heir3
               CALL  plnge1
               LD    (IX+2),L
               LD    (IX+3),H  ;k=plnge1(heir3,lval)
               CALL  vycisli
               LD    A,":"
               CALL  needtoken
               LD    L,(IX+0)
               LD    H,(IX+1)
               PUSH  HL
               INC   HL
               CALL  jump
               POP   HL
               CALL  postlabel
               LD    E,(IX+4)
               LD    D,(IX+5)
               LD    HL,heir3
               CALL  plnge1
               LD    (IX+2),L
               LD    (IX+3),H  ;k=plnge1(heir3,lval)
               CALL  vycisli
               LD    L,(IX+0)
               LD    H,(IX+1)
               INC   HL
               CALL  postlabel
               LD    (IX+2),0  ;k=0
               LD    (IX+3),0
               LD    L,(IX+4)
               LD    H,(IX+5)
               XOR   A
               INC   HL
               INC   HL

               LD    (HL),A    ;2
               INC   HL
               LD    (HL),A
               INC   HL

               LD    (HL),A    ;4
               INC   HL
               LD    (HL),A
               INC   HL

               LD    (HL),A    ;6
               INC   HL
               LD    (HL),A
               INC   HL

               INC   HL        ;8
               INC   HL

               LD    (HL),1    ;10

               INC   HL
               INC   HL
               INC   HL
               INC   HL


               LD    (HL),A    ;14
               INC   HL
               LD    (HL),A
               INC   HL
               JP    eter

heir3:         EX    DE,HL
               LD    HL,he3
               LD    (myst),HL
               LD    HL,eq0
               LD    (myst+2),HL
               LD    HL,1
               LD    (myst+4),HL
               DEC   HL
               LD    (myst+6),HL
               LD    HL,heir4
               LD    (myst+8),HL
               EX    DE,HL
               LD    (myst+10),HL
               JP    skim


heir4:         EX    DE,HL
               LD    HL,he4
               LD    (myst),HL
               LD    HL,ne0
               LD    (myst+2),HL
               LD    HL,0
               LD    (myst+4),HL
               INC   HL
               LD    (myst+6),HL
               LD    HL,heir5
               LD    (myst+8),HL
               EX    DE,HL
               LD    (myst+10),HL
               JP    skim

heir5:         LD    B,H
               LD    C,L
               LD    HL,he5
               XOR   A
               LD    DE,heir6
               JP    plnge

heir6:         LD    B,H
               LD    C,L
               LD    HL,he6
               LD    A,1
               LD    DE,heir7
               JP    plnge

heir7:         LD    B,H
               LD    C,L
               LD    HL,he7
               LD    A,2
               LD    DE,heir8
               JP    plnge

heir8:         LD    B,H
               LD    C,L
               LD    HL,he8
               LD    A,3
               LD    DE,heir9
               JP    plnge

heir9:         LD    B,H
               LD    C,L
               LD    HL,he9
               LD    A,5
               LD    DE,heir10
               JP    plnge

heir10:        LD    B,H
               LD    C,L
               LD    HL,he10
               LD    A,9
               LD    DE,heir11
               JP    plnge

heir11:        LD    B,H
               LD    C,L
               LD    HL,he11
               LD    A,11
               LD    DE,heir12
               JP    plnge

heir12:        LD    B,H
               LD    C,L
               LD    HL,he12
               LD    A,13
               LD    DE,heir13
               JP    plnge


heir13:        PUSH  HL    ; ptr
               PUSH  HL    ; k
               PUSH  HL    ; lval

               CALL  blanks
               CP    "("
               JP    NZ,h9

retype:        LD    HL,(lptr)
               PUSH  HL
               LD    A,"("
               CALL  needtoken
               CALL  settype
               JP    Z,h91

               LD    (dtype3),A
               PUSH  AF
               BIT   7,A
               CALL  NZ,dostruct
               POP   AF
               LD    (dtype),A
               POP   HL       ; pojde o retyping

               LD    A,"*"
               CALL  matches
               LD    A,POINTER
               JR    Z,$+4
               LD    A,VARIABLE
               LD    (jj),A
               SUB   POINTER
               LD    HL,(dtype)  ; L=type H=IDENT-pointer
               LD    H,A
               PUSH  HL
               LD    A,")"
               CALL  needtoken
               POP   DE
               POP   HL
               PUSH  HL
               PUSH  DE
               CALL  heir13  ; nz = lvalue
               LD    H,0
               LD    (kkkk+1),HL
               POP   BC
               EX    DE,HL   ; hl=lval
               POP   HL      ; de=k

               PUSH  HL
               CALL  hlhl    ; bc=typ, hl=ptr
               LD    A,H
               OR    L
               JR    Z,h92   ; skok ak nema symbol

               LD    A,(HL)
               CP    ARRAY
               LD    A,(jj)  ; urob pointer or variable
               JR    Z,$+3
               LD    (HL),A  ; ARRAY ostava
               INC   HL      ; ak nebol pointer, zmen len typ
               LD    (HL),C  ; POINTER to type
               DEC   HL

               CALL  isu
               LD    D,A

               PUSH  DE      ; urob aj size, one a menostr
               PUSH  BC
               LD    A,C
               PUSH  HL
               CALL  size
               POP   HL
               LD    DE,SIZEOF
               ADD   HL,DE
               LD    (HL),C
               LD    E,ONE-SIZEOF
               ADD   HL,DE
               LD    (HL),C
               INC   HL
               INC   HL
               INC   HL
               LD    DE,(menovka)
               CALL  hlde
               POP   BC
               POP   DE
               POP   HL

               PUSH  HL             ; hl - lval
               CALL  hlhl           ; hl - ptr[class]
               LD    A,(HL)
               CP    ARRAY
               INC   HL
               INC   HL
               JR    NZ,h93
               POP   HL
               INC   HL
               INC   HL
               INC   HL
               INC   HL
               LD    (HL),C
               JR    h94            ; ARRAY nerobi lval

h93:           LD    A,(HL)
               CP    AUTOMATIC
               JR    h92+1

h92:           INC   A
               POP   HL         ; Z if local
               INC   HL
               INC   HL         ; hl=&lval[1]
               LD    (HL),C     ; 0 alebo zaremovat
               JR    NZ,$+4
               LD    (HL),CINT  ; ide o lokalnu premennu
               INC   HL
               INC   HL
               INC   B
               DEC   B
               LD    A,C
               JR    Z,$+4      ; ide o ukaztel
               LD    A,0
               LD    (HL),A     ;

h94:           INC   HL
               INC   HL
               INC   HL
               LD    (HL),D     ; unsigned rozsirenie
               POP   HL
               POP   HL
kkkk:          LD    DE,0
               LD    D,0
               LD    A,D
               OR    E
               EX    DE,HL      ;return k;
               RET

h91:           POP   HL
               LD    (lptr),HL

h9:            LD    A,To+27  ; ++
               CALL  matches
               JR    NZ,h0

               POP   HL
               PUSH  HL
               CALL  heir13
               JR    NZ,h00
               CALL  needlval
gg:            POP   HL
               POP   HL
               POP   HL
               JP    nula
h00:           LD    HL,incr
               POP   DE
               PUSH  DE
               CALL  step
               JR    gg

h0:            LD    A,To+28  ;--
               CALL  matches
               JR    NZ,h1

               POP   HL
               PUSH  HL
               CALL  heir13
               JR    NZ,g01
               CALL  needlval
               JR    gg
g01:           LD    HL,decr
               POP   DE
               PUSH  DE
               CALL  step
               JR    gg

h1:            LD    A,"~"
               CALL  matches
               JR    NZ,h2

               POP   HL
               PUSH  HL
               CALL  heir13
               JR    Z,h02

               POP   HL
               PUSH  HL
               CALL  rvalue
h02:           CALL  com
               POP   HL
               PUSH  HL
               LD    DE,4*2
               ADD   HL,DE
               PUSH  HL
               LD    E,(HL)
               INC   HL
               LD    D,(HL)
               EX    DE,HL
               CALL  CCCOM
               EX    DE,HL
               POP   HL
               LD    (HL),E
               INC   HL
               LD    (HL),D
               JP    gg

h2:            LD    A,"!"
               CALL  matches
               JR    NZ,h3

               POP   HL
               PUSH  HL
               CALL  heir13
               JR    Z,h03

               POP   HL
               PUSH  HL
               CALL  rvalue
h03:           CALL  lneg
               POP   HL
               PUSH  HL
               LD    DE,4*2
               ADD   HL,DE
               PUSH  HL
               LD    E,(HL)
               INC   HL
               LD    D,(HL)
               EX    DE,HL
               CALL  CCLNEG
               EX    DE,HL
               POP   HL
               LD    (HL),E
               INC   HL
               LD    (HL),D
               JP    gg

h3:            LD    A,"-"
               CALL  matches
               JR    NZ,h41

               POP   HL
               PUSH  HL
               CALL  heir13
               JR    Z,h04

               POP   HL
               PUSH  HL
               CALL  rvalue
h04:           CALL  negate
               POP   HL
               PUSH  HL
               LD    DE,4*2
               ADD   HL,DE
               PUSH  HL
               LD    E,(HL)
               INC   HL
               LD    D,(HL)
               EX    DE,HL
               CALL  CCNEG
               EX    DE,HL
               POP   HL
               LD    (HL),E
               INC   HL
               LD    (HL),D
               JP    gg

h41:           LD    A,"+"      ; unary +
               CALL  matches
               JR    NZ,h42
               POP   HL
               PUSH  HL
               CALL  heir13
               POP   HL
               PUSH  HL
               CALL  NZ,rvalue
               JP    gg

h42:           LD    A,Tdefined ; unary defined
               CALL  matches
               JR    NZ,h4

               LD    A,"("
               CALL  matches
               LD    HL,msname
               PUSH  HL
               CALL  symname
               CALL  NC,illname
               LD    A,")"
               CALL  matches
               POP   HL
               LD    (stru),HL
               LD    HL,macn
               LD    (stru+2),HL
               LD    HL,NAMEMAX+3
               LD    (stru+4),HL
               LD    HL,MACEND
               LD    (stru+6),HL
               LD    HL,MACNBR
               LD    (stru+8),HL
               LD    HL,0
               LD    (stru+10),HL
               CALL  search
               LD    HL,0
               CALL  NZ,jedna   ; 1 or 0
               EX    DE,HL
               POP   HL
               PUSH  HL
               LD    B,16       ; clear lval
               XOR   A
               LD    (HL),A
               INC   HL
               DJNZ  $-2
               POP   HL
               PUSH  HL
               LD    BC,6       ; lval[3]=1; lval[4]=value;
               ADD   HL,BC
               LD    (HL),1
               INC   HL
               INC   HL
               CALL  hlde
               JP    gg         ; return 0;

h4:            LD    A,"*"
               CALL  matches
               JR    NZ,h5
               POP   HL
               PUSH  HL
               CALL  heir13
               POP   HL
               PUSH  HL
               CALL  NZ,rvalue
               POP   HL
               PUSH  HL
               LD    DE,2*2
               ADD   HL,DE
               LD    A,(HL)
               AND   A
               JR    NZ,ip
               CALL  warning
               DM    "pointer required"
               NOP
ip:            POP   HL
               POP   DE
               POP   BC
               LD    C,(HL)
               INC   HL
               LD    B,(HL)
               INC   HL       ; BC=ptr
               LD    A,B
               OR    C
               JR    NZ,hx    ; implicint NULL
               INC   HL       ; if ptr NULL
               INC   HL
               LD    A,(HL)   ; lval[1]=lval[2]
               DEC   HL
               DEC   HL
               JR    h005
hx:            INC   BC
               LD    A,(BC)   ; get type
h005:          LD    (HL),A   ; lval[1]=ptr[type] or CINT
               INC   HL
               INC   HL
               PUSH  HL
               DEC   BC
               LD    L,C
               LD    H,B
               LD    A,0
               JR    Z,ho5    ; ZERO if not ptr
               CALL  gettype  ; next ident
               LD    A,POINTER
               CP    C
               LD    A,0
               JR    NZ,ho5
               POP   HL
               PUSH  HL
               DEC   HL
               DEC   HL
               LD    (HL),CINT ; lval[1]=CINT if pointer
               LD    A,B       ; lval[2]=type if pointer
ho5:           POP   HL
               LD    (HL),A
               INC   HL
               INC   HL
               LD    (HL),0  ; non constant
               INC   HL
               LD    A,B     ; ???
               AND   1
               LD    (HL),A  ; lval[7]=type&1 - sign
               JP    jedna   ; as var or pointer

h5:            LD    A,"&"
               CALL  matches
               JR    NZ,h66

               POP   HL
               PUSH  HL
               CALL  heir13
               JR    NZ,h06

illadr:        CALL  error
               DM    "illegal address"
               NOP
               JP    gg

h06:           POP   HL
               POP   DE
               POP   BC
               LD    C,(HL)
               INC   HL
               LD    B,(HL)
               DEC   HL
               PUSH  BC
               PUSH  DE
               PUSH  HL
               INC   BC
               LD    A,(BC)
               INC   BC
               LD    A,(BC)
               CP    REGISTER
               JR    Z,illadr

               DEC   BC
               LD    A,(BC)
               LD    DE,2*2
               ADD   HL,DE
               LD    (HL),A

               INC   HL
               INC   HL
               INC   HL
               LD    (HL),1  ; pointer is uns
               LD    DE,-5
               ADD   HL,DE
               LD    A,(HL)
               AND   A
               JP    NZ,gg
               PUSH  HL
               PUSH  BC

               DEC   BC
               LD    L,C
               LD    H,B
               CALL  address

               POP   BC
               POP   HL
               LD    A,(BC)
               LD    (HL),A
               JP    gg

h66:           LD    A,Tsizeof
               CALL  matches
               JR    NZ,h6

               LD    A,"("
               CALL  needtoken
               CALL  settype
               JR    Z,obj
               BIT   7,A
               PUSH  AF
               CALL  NZ,dostruct
               POP   AF
               CALL  size
               LD    L,C
               LD    H,0
               JR    issize2

obj:           POP   HL      ; name of object
               PUSH  HL
               CALL  primary
               POP   HL
               PUSH  HL
               CALL  hlhl
               LD    DE,SIZEOF
               ADD   HL,DE
               CALL  hlhl
               LD    A,H
               OR    L
               JR    NZ,issize2
               PUSH  HL
               CALL  warning
               DM    "NULL size"
               NOP
               POP   HL
issize2:       EX    DE,HL
               POP   HL        ; de = sizeof
               PUSH  HL
               LD    BC,3*2
               ADD   HL,BC
               LD    (HL),1    ; ako konstanta
               INC   HL
               INC   HL
               LD    (HL),E    ; a vyhodnot
               INC   HL
               LD    (HL),D
               EX    DE,HL
               CALL  const
               LD    A,")"
               CALL  needtoken
               JP    gg

h6:            POP   HL
               PUSH  HL
               CALL  heir14
               POP   DE
               POP   BC
               PUSH  HL
               PUSH  DE

               LD    A,To+27        ; ++
               CALL  matches
               JR    NZ,h7

               POP   DE
               POP   HL
               PUSH  HL
               PUSH  DE
               LD    A,H
               OR    L
               JR    NZ,$+8

               CALL  needlval
               JP    gg

               LD    HL,incr
               POP   DE
               PUSH  DE
               CALL  step2
               JP    gg

h7:            LD    A,To+28
               CALL  matches  ; --
               JR    NZ,h8
               POP   DE
               POP   HL
               PUSH  HL
               PUSH  DE
               LD    A,H
               OR    L
               JR    NZ,$+8
               CALL  needlval
               JP    gg
               LD    HL,decr
               POP   DE
               PUSH  DE
               CALL  step2
               JP    gg

h8:            POP   HL
               POP   HL
               POP   AF
               LD    A,H
               OR    L
               RET

heir14:        EX    DE,HL          ; hl=lval
               LD    HL,-30
               ADD   HL,SP
               LD    SP,HL
               PUSH  HL
               EX    (SP),IX
               LD    (IX+0),E
               LD    (IX+1),D
               EX    DE,HL
               PUSH  HL
               CALL  primary
               LD    (IX+2),L   ; k=primary ();
               LD    (IX+3),H
               POP   HL
               LD    E,(HL)
               INC   HL
               LD    D,(HL)
               LD    (IX+24),E
               LD    (IX+25),D
               CALL  blanks
               LD    A,(ch)
               CP    "["
               JR    Z,whil31
               CP    48+To  ; ->
               JR    Z,whil31
               CP    "."
               JR    Z,whil31
               CP    "("
               JP    NZ,i0

whil31:        LD    A,"["
               CALL  matches
               JP    NZ,i3

               LD    L,(IX+0)
               LD    H,(IX+1)
               LD    DE,10
               ADD   HL,DE
               LD    (HL),1  ; de used
               LD    L,(IX+24)
               LD    H,(IX+25)
               LD    A,H
               OR    L
               JR    NZ,i4

               CALL  error
               DM    "can't subscript"
               NOP
               CALL  junk
               LD    A,"]"
               CALL  needtoken
               JP    nuls

i4:            LD    A,(HL)
               CP    POINTER
               JR    NZ,i5

               LD    (HL),ARRAY   ; po rvalue je to uz array
               LD    L,(IX+0)
               LD    H,(IX+1)
               CALL  rvalue
               JR    i6

i5:            CP    ARRAY
               JR    Z,i6

               CALL  error
               DM    "can't subscript"
               NOP
               LD    (IX+2),0

i6:            LD    HL,26+2   ; urob index var
               ADD   HL,SP
               LD    D,H
               LD    E,L
               INC   DE
               INC   DE
               CALL  setstage
               LD    HL,8+6+2
               ADD   HL,SP
               LD    (HL),0

               LD    HL,0
               LD    (pstruct),HL
               LD    (pstruct+2),HL
               LD    HL,heir1
               LD    (pstruct+4),HL
               LD    HL,8+2
               ADD   HL,SP
               LD    (pstruct+6),HL
               LD    (pstruct+8),HL
               CALL  plnge2            ; urob kod indexu
               LD    A,"]"
               CALL  needtoken

               LD    L,(IX+24)
               LD    H,(IX+25)
               LD    DE,PARMS
               ADD   HL,DE
               LD    A,(HL)
               CP    2
               JP    NC,multidim

               LD    A,(IX+14)      ; jednorozmerne polia
               AND   A
               JR    Z,i7
               LD    L,(IX+26)       ; if const index
               LD    H,(IX+27)
               LD    DE,0
               CALL  clearstage
               LD    A,(IX+16)       ; if != 0
               OR    (IX+17)
               JP    Z,i8
               LD    L,(IX+24)
               LD    H,(IX+25)
               LD    DE,IDENT2
               ADD   HL,DE
               LD    A,(HL)
               SBC   HL,DE
               CP    POINTER
               LD    DE,2
               JR    Z,isn5   ; pole ukazatelov
               INC   HL
               LD    A,(HL)
               BIT   7,A
               JR    Z,isn4
               LD    DE,ONE-1
               ADD   HL,DE
               LD    D,0
               LD    E,(HL)
               JR    isn5

isn4:          AND   MASK
               CP    CINT
               LD    DE,1
               JR    NZ,isn5
               INC   E
isn5:          LD    L,(IX+16)
               LD    H,(IX+17)
               CALL  CCMUL
               CALL  const2
               CALL  ffadd
               JR    i8

i7:            LD    L,(IX+24)   ; no const index
               LD    H,(IX+25)
               LD    DE,IDENT2
               ADD   HL,DE
               LD    A,(HL)
               SBC   HL,DE
               CP    POINTER
               LD    A,CINT
               JR    Z,isn6         ; pole ukazatelov
               INC   HL
               LD    A,(HL)
               BIT   7,A
               JR    Z,isn6
               LD    L,(IX+24)
               LD    H,(IX+25)
               LD    DE,ONE
               ADD   HL,DE
               LD    L,(HL)
               LD    H,0
               CALL  log         ; 2 4 8 16 32
               JR    Z,isn7
               PUSH  HL
               CALL  pushrh
               POP   HL
               CALL  const2      ; hl*sizeof(object)
               CALL  ffmult
               CALL  popr
               JR    isn7

isn6:          AND   MASK
               CP    CINT
               CALL  Z,doublereg
isn7:          CALL  ffadd

i8:            LD    L,(IX+0)     ; urcenie typu vysledku
               LD    H,(IX+1)
               PUSH  HL
               CALL  hlhl     ; hl=ptr
               CALL  gettype
               LD    E,B
               LD    A,POINTER
               CP    C
               LD    C,CINT
               JR    Z,hw5
               LD    C,B       ; no pointer
               LD    B,0
hw5:           POP   HL
               INC   HL
               INC   HL
               LD    (HL),C    ; lval[1]=C
               INC   HL        ; lval[2]=B
               INC   HL
               LD    (HL),B
               INC   HL
               INC   HL
               LD    (HL),0    ; no const
               INC   HL
               LD    A,E
               AND   1
               LD    (HL),A
               LD    (IX+2),1  ; k=1
               JP    whil31

multidim:      LD    DE,EXTEND-PARMS    ; viacrozmerne
               DEC   A
               LD    (HL),A
               ADD   HL,DE
               PUSH  HL
               CALL  hlhl
               LD    C,(HL)    ; BC=velkost rozmeru
               INC   HL
               LD    B,(HL)
               INC   HL
               POP   DE
               EX    DE,HL
               LD    (HL),E
               INC   HL
               LD    (HL),D
               LD    A,(IX+14)
               AND   A
               JR    Z,ncons

               PUSH  BC        ; konstantny index
               LD    L,(IX+26)
               LD    H,(IX+27)
               LD    DE,0
               CALL  clearstage
               POP   HL
               LD    E,(IX+16)       ; if != 0
               LD    D,(IX+17)
               LD    A,D
               OR    E
               JP    Z,i8x
               CALL  CCMUL
               PUSH  HL
               LD    L,(IX+24)
               LD    H,(IX+25)
               INC   HL
               LD    A,(HL)
               BIT   7,A
               JR    Z,isn4x
               LD    DE,ONE-1
               ADD   HL,DE
               LD    D,0
               LD    E,(HL)
               JR    isn5x

isn4x:         AND   MASK
               CP    CINT
               LD    DE,1
               JR    NZ,isn5x
               INC   E
isn5x:         POP   HL
               CALL  CCMUL
               CALL  const2
               CALL  ffadd
               JR    i8x

ncons:         PUSH  BC
               CALL  pushrh
               LD    L,(IX+24)   ; no const index
               LD    H,(IX+25)
               INC   HL
               LD    A,(HL)
               BIT   7,A
               JR    Z,isn6x
               LD    L,(IX+24)
               LD    H,(IX+25)
               LD    DE,ONE
               ADD   HL,DE
               LD    L,(HL)
               LD    H,0
               POP   DE
               CALL  CCMUL
               JR    isn7x

isn6x:         AND   MASK
               CP    CCHAR
               POP   HL
               JR    Z,$+3
               ADD   HL,HL

isn7x:         CALL  log
               JR    Z,$+2+6
               CALL  const2
               CALL  ffmult
               CALL  popr
               CALL  ffadd        ; hl+de

i8x:           LD    L,(IX+24)
               LD    H,(IX+25)
               INC   HL
               LD    A,(HL)
               LD    L,(IX+0)
               LD    H,(IX+1)
               INC   HL
               INC   HL
               LD    (HL),0    ; lval[2]=ptr[type]
               INC   HL
               INC   HL        ; as not pointer !!!!!!!!!!!!
               LD    (HL),A    ; lval[1]=0
               LD    (IX+2),0  ; k=0
               JP    whil31

i3:            CALL  match
               DB    "("
               JP    NZ,m5

               LD    L,(IX+24)    ; funkcia
               LD    H,(IX+25)
               LD    A,H
               OR    L
               JP    Z,i02        ; 123();

               LD    A,(HL)
               CP    FUNCTION
               JR    Z,i01
               CP    POINTER
               JR    Z,i0x
               PUSH  HL
               CALL  error
               DM    "fnc or fnc pointer required"
               NOP
               POP   HL

i0x:           LD    L,(IX+0)  ; lval
               LD    H,(IX+1)
               CALL  rvalue ; if (k)
               LD    (IX+2),0

               JR    i02

ie7:           LD    A,(IX+2)  ; k
               AND   A
ie4:           LD    L,(IX+0)  ; lval
               LD    H,(IX+1)
               CALL  Z,rvalue ; if (k)

i02:           LD    HL,0
               CALL  callfunction ; call indirect
               JR    m7

i01:           INC   HL         ; funkcia
               INC   HL
               LD    A,(HL)
               DEC   HL
               DEC   HL
               CP    AUTOMATIC
               JR    Z,i02          ;
               LD    A,(IX+2)  ; k
               AND   A
               JR    NZ,ie4

               PUSH  HL           ; call absolute
               CALL  callfunction
               POP   HL

m7:            XOR   A          ; nastav novy typ
               LD    (IX+2),A
               LD    (IX+3),A   ; k=0
               LD    L,(IX+0)
               LD    H,(IX+1)   ; hl=lval
               PUSH  HL
               CALL  hlhl       ; b=type
               CALL  gettype    ; c=ident
               EX    (SP),IX
               XOR   A
               LD    (IX+4),B   ; lval[2]=ptr[type]
               LD    A,POINTER
               CP    C
               JR    Z,$+6
               LD    (IX+4),0   ; lval[2]=0
               LD    (IX+6),0   ; as noconstant
               LD    L,(IX+0)
               LD    H,(IX+1)
               LD    A,H
               OR    L
               JR    Z,setint
               CALL  isu
setint:        LD    (IX+7),A   ; !!!!!!!!!!!!!!!!!!!!!
               LD    (IX+10),1  ; DE is used
               LD    (IX+11),1  ; (ix+11) !!! bolo volanie
               POP   IX
               JP    whil31

m5:            LD    A,48+To
               CALL  matches
               JR    NZ,m6
               LD    L,(IX+0)
               LD    H,(IX+1)
               LD    DE,4
               ADD   HL,DE
               LD    A,(HL)
               LD    (HL),0  ; uz nieje pointer
               SBC   HL,DE
               AND   A
               JR    NZ,df
               CALL  error
               DM    "must be pointer"
               NOP
df:            CALL  rvalue
               JR    ms

m6:            LD    A,"."
               CALL  matches
               JP    NZ,i1

m61:           LD    L,(IX+0)
               LD    H,(IX+1)
               INC   HL
               INC   HL
               LD    A,(HL)
               AND   A       ; indirect ?
               JR    NZ,mh
               DEC   HL
               DEC   HL
               PUSH  HL
               LD    DE,11
               ADD   HL,DE
               LD    A,(HL)
               POP   HL
               CP    1
               JR    Z,ms      ; islo o vycislenu fciu
               CALL  hlhl      ; ld hl,addrstruct
               CALL  address

ms:            LD    L,(IX+0)  ; a otestuj ci je struct
               LD    H,(IX+1)
               CALL  hlhl
               INC   HL
               LD    A,(HL)
               BIT   7,A
               JR    NZ,mh
               CALL  error
               DM    "struct or union required"
               NOP

mh:            LD    HL,8+2   ; lval2
               ADD   HL,SP
               PUSH  HL
               CALL  primary
               LD    (IX+2),L ; k=primary(lval2)
               LD    (IX+3),H
               POP   HL
               CALL  hlhl     ; hl=ptr of tags
               PUSH  HL
               LD    L,(IX+0)
               LD    H,(IX+1)
               CALL  hlhl
               POP   DE
               EX    DE,HL
               LDI           ; type=type2
               LDI           ; ident=ident2
               DEC   HL
               LD    B,(HL)   ; A=type tags
               DEC   HL
               LD    C,(HL)   ; A=ident tags
               PUSH  BC
               PUSH  HL
               LD    DE,OFFSET
               ADD   HL,DE
               CALL  hlhl
               LD    A,H
               OR    L
               JR    Z,mg
               CALL  const3
               LD    HL,mov41
               CALL  ol
mg:            LD    L,(IX+0)  ; hl=lval
               LD    H,(IX+1)  ; ix+8=lval2
               POP   DE
               POP   BC          ; lval[1]=ptr[type].tags
               INC   HL
               INC   HL
               LD    A,POINTER
               CP    C
               JR    NZ,$+4
               LD    B,CINT
               LD    (HL),B
               INC   HL
               LD    (HL),C
               INC   HL
               LD    A,(IX+8+4)  ; lval[2]=lval2[2]
               LD    (HL),A
               INC   HL
               INC   HL
               LD    (HL),0      ; lval[3]=0
               INC   HL
               EX    DE,HL
               CALL  isu
               EX    DE,HL
               LD    (HL),A      ; pointer unsigned
               LD    HL,INFOBYTE
               ADD   HL,DE
               BIT   3,(HL)
               RES   3,(HL)
               JP    NZ,whil31
               CALL  error
               DM    "struct or union member expected"
               NOP
               JP    whil31

i0:            LD    A,(IX+24)  ; ani ( [ . ->
               OR    (IX+25)
               JR    Z,i1
               LD    L,(IX+0)
               LD    H,(IX+1)
               LD    DE,11
               ADD   HL,DE
               LD    A,(HL)
               CP    1
               JR    Z,i1       ; fnc in ( )

               LD    L,(IX+24)
               LD    H,(IX+25)
               LD    A,(HL)
               CP    FUNCTION
               JR    NZ,i1
               CALL  address
               LD    L,(IX+0)
               LD    H,(IX+1)
               LD    (HL),0
               INC   HL
               LD    (HL),0
               LD    DE,6
               ADD   HL,DE
               LD    (HL),1
nuls:          LD    DE,0
               JP    i00

i1:            LD    E,(IX+2)
               LD    D,(IX+3)
i00:           POP   IX
               LD    HL,30
               ADD   HL,SP
               LD    SP,HL
               LD    A,D
               OR    E
               EX    DE,HL
               RET
primary:                            ; hl = lval
                                    ; vracia nula/jedna
               PUSH  HL
               EX    (SP),IX
               LD    HL,-4-NAMEMAX
               ADD   HL,SP
               LD    SP,HL
               LD    A,"("
               CALL  matches
               JR    NZ,f0
               PUSH  IX
               POP   HL
               CALL  heir1
               PUSH  HL
d21:           LD    A,","
               CALL  matches
               JR    Z,d21
               LD    A,")"
               CALL  needtoken
               POP   DE

d201:          LD    HL,NAMEMAX+4
               ADD   HL,SP
               LD    SP,HL
               LD    L,(IX+0)
               LD    H,(IX+1)  ; hl=ptr
               CALL  isu
               LD    (IX+7),A   ; unsigned flag

fromconst:     POP   IX
               EX    DE,HL
               LD    A,H
               OR    L
               RET

f0:            PUSH  IX
               POP   HL
               LD    B,8*2
               LD    (HL),0
               INC   HL
               DJNZ  $-3     ; clear lval array

               LD    A,":"
               CALL  matches
               LD    A,":"
               CALL  matches
               LD    (prislus),A
               LD    HL,0
               ADD   HL,SP
               PUSH  HL
               CALL  symname
               POP   HL
               JP    NC,f1     ;skus to z konstantou
               DB    62
prislus:       NOP
               AND   A
               JP    Z,f3      ; bol pouzity "::" operator

               CALL  findloc   ;hl=sname
               EX    DE,HL
               LD    HL,NAMEMAX
               ADD   HL,SP
               LD    (HL),E
               INC   HL
               LD    (HL),D
               LD    A,D
               OR    E
               EX    DE,HL     ; hl = ptr
               JR    Z,f3

               LD    DE,INFOBYTE
               ADD   HL,DE
               SET   2,(HL)    ; oznac objekt ako pouzity
               SBC   HL,DE

               CALL  copysym
               LD    (IX+0),L
               LD    (IX+1),H
               INC   HL
               INC   HL
               LD    A,(HL)
               DEC   HL
               CP    AUTOMATIC
               LD    C,0
               JR    NZ,noauto

               DEC   HL
               PUSH  HL
               CALL  getloc    ;hl=ptr
               POP   HL
               INC   HL
               LD    A,(HL)
               LD    B,A
               LD    C,CINT
               LD    (IX+2),A  ; lval [1]=ptr[2];

noauto:        DEC   HL
               LD    A,(HL)
               CP    POINTER
               JR    NZ,f5

               LD    (IX+2),C
               LD    (IX+4),B

f5:            CP    ARRAY
               JP    NZ,f7
               LD    (IX+4),B
               JP    endpri

f3:            LD    HL,0
               ADD   HL,SP
               CALL  findglb   ; ide o global symbol
               JP    Z,f2      ; nie ,pridaj ho

               LD    DE,INFOBYTE
               ADD   HL,DE
               SET   2,(HL)    ; oznac objekt ako pouzity
               SBC   HL,DE

               CALL  copysym
               LD    A,(HL)    ; ide o label ?
               CP    LABEL
               JR    NZ,f4

               CALL  experr
               JP    endpri

f4:            EX    DE,HL
               LD    HL,NAMEMAX
               ADD   HL,SP
               LD    (HL),E
               INC   HL
               LD    (HL),D
               EX    DE,HL     ; hl = ptr

               LD    DE,CLASS
               ADD   HL,DE
               LD    A,(HL)
               SBC   HL,DE
               CP    TYPEDEF
               JR    NZ,lz
               CALL  error
               DM    "typedef class in expression"
               NOP
lz:            LD    A,(HL)
               CP    FUNCTION
               SCF
               JP    Z,fdef

               CP    SYMBOL
               JR    NZ,nosymb
               LD    DE,OFFSET
               ADD   HL,DE
               CALL  hlhl
               PUSH  HL
               CALL  const
               POP   HL
               LD    (IX+6),1
               LD    (IX+8),L
               LD    (IX+9),H
               JP    endpri      ;ret 1

nosymb:        CP    MENOVKA
               JP    Z,endpri

               LD    (IX+0),L
               LD    (IX+1),H
               LD    (IX+2),0
               CP    ARRAY
               JR    Z,f6

               CP    POINTER
               JR    NZ,f7
               INC   HL
               LD    A,(HL)
               LD    (IX+4),A
f7:            LD    DE,1
               JP    d201

f6:            CALL  address
               LD    HL,NAMEMAX
               ADD   HL,SP
               CALL  hlhl
               INC   HL
               LD    A,(HL)
               LD    (IX+2),A
               LD    (IX+4),A
               INC   HL               ;
               LD    (HL),AUTOMATIC   ;
               JP    endpri

f2:            LD    HL,(lptr)
               LD    A," "
nastavu:       CP    (HL)
               JR    NZ,nastave
               INC   HL
               JR    nastavu
nastave:       LD    A,(HL)
               CP    "("
               JR    Z,f22           ; ide o nedefinovanu fciu
               CALL  warning
               DM    "undefined symbol - int used"
               NOP
               LD    HL,0
               ADD   HL,SP
               LD    (stru2),HL      ; sname
               LD    HL,VARIABLE
               LD    (stru2+2),HL
               LD    HL,CINT
               LD    (stru2+4),HL
               LD    HL,0
               LD    (stru2+6),HL
               LD    HL,glbptr
               LD    (stru2+8),HL
               LD    HL,STATIC
               LD    (stru2+10),HL
               LD    HL,2
               LD    (stru2+12),A
               LD    H,0
               LD    (stru2+14),HL
               CALL  addsym
               LD    DE,INFOBYTE
               ADD   HL,DE
               SET   2,(HL)
               SBC   HL,DE
               CALL  copysym
               LD    (IX+0),L
               LD    (IX+1),H
               LD    (IX+2),0
               LD    (IX+3),0
               LD    DE,1
               JP    d201

f22:           LD    A,(test2)
               BIT   0,A
               JR    Z,ew
               CALL  warning
               DM    "function declared implicit int"
               NOP

ew:            LD    HL,0
               ADD   HL,SP
               LD    (stru2),HL      ; sname
               LD    HL,FUNCTION
               LD    (stru2+2),HL
               LD    HL,CINT
               LD    (stru2+4),HL
               LD    HL,0
               LD    (stru2+6),HL
               LD    HL,glbptr
               LD    (stru2+8),HL
               LD    HL,AUTOEXT
               LD    (stru2+10),HL
               LD    HL,-1          ;size -1
               LD    (stru2+12),A
               LD    H,0            ;id 3 null
               LD    (stru2+14),HL  ; variadic
comdef:        CALL  addsym
               LD    DE,INFOBYTE
               ADD   HL,DE
               SET   2,(HL)
               SBC   HL,DE
               AND   A
               CALL  copysym

fdef:          LD    (IX+0),L
               LD    (IX+1),H
               LD    (IX+2),0
               LD    (IX+3),0
               JR    NC,endpri

               LD    DE,IDENT2
               ADD   HL,DE
               LD    A,(HL)
               CP    POINTER
               JR    NZ,endpri
               SBC   HL,DE
               INC   HL
               LD    A,(HL)     ; A =type of pointer
               LD    (IX+4),A   ; if *fnc
               JR    endpri

f1:            PUSH  IX
               POP   HL
               CALL  constant
               CALL  Z,experr
endpri:        LD    DE,0
               LD    HL,NAMEMAX+4
               ADD   HL,SP
               LD    SP,HL
               JP    fromconst

experr:        CALL  error
               DM    "invalid expression"
               DB    0
               LD    HL,0
               CALL  const
               JP    junk

isu:           LD    A,(HL)
               CP    POINTER
               RET   Z
               CP    ARRAY
               RET   Z
               INC   HL
               LD    A,(HL)
               DEC   HL
               CP    CUCHAR
               RET   Z
               CP    CUINT
               RET   Z
               XOR   A
               RET

copysym:       LD    DE,(symbuf)
               PUSH  DE
               LD    BC,SYMMAX
               LDIR
               LD    HL,SYMMAX*20+symbuf
               AND   A
               SBC   HL,DE
               JR    NC,$+5
               LD    DE,symbuf+2
               LD    (symbuf),DE
               POP   HL
               RET

gettype:       PUSH  HL
               EX    (SP),IX
               LD    A,(IX+IDENT2)
               LD    (IX+IDENT),A
               LD    C,A             ;ident
               LD    A,(IX+IDENT3)
               LD    (IX+IDENT2),A
               LD    B,(IX+TYPE)     ;type
               POP   IX
               RET

callfunction:  PUSH  HL    ; hl =entry table
               PUSH  HL    ; val
               PUSH  HL    ; const

               XOR   A
               PUSH  AF    ; nargs
               CALL  blanks
               LD    A,(usereg)
               AND   A
               JR    Z,whil21x
               LD    A,(pushreg)
               AND   A
               JR    Z,whil21x
               LD    A,(usereg)
               CP    1
               JR    NZ,obaix

               LD    HL,(csp) ; save ix
               DEC   HL
               DEC   HL
               LD    (csp),HL
               LD    HL,t3
               CALL  ol
               JR    whil21x

obaix:         LD    HL,(csp) ; save ix iy
               LD    DE,-4
               ADD   HL,DE
               LD    (csp),HL
               LD    HL,t3
               CALL  ol
               INC   HL
               CALL  ol

whil21x:       LD    HL,6
               ADD   HL,SP
               CALL  hlhl
               OR    H           ; if (ptr)
               CALL  Z,ccmodify

whil21:        LD    HL,(lptr)
               LD    A,(HL)
               CP    ")"
               JR    Z,nargs
               CALL  endst
               JR    NZ,nargs

               LD    HL,2
               ADD   HL,SP
               LD    D,H
               LD    E,L
               INC   DE
               INC   DE
               CALL  expression
               CALL  pushr

               POP   AF
               ADD   BPW
               PUSH  AF
               CALL  match
               DB    ","
               JR    Z,whil21

nargs:         LD    A,")"
               CALL  needtoken

               LD    HL,0
               ADD   HL,SP
               PUSH  HL
               EX    (SP),IX
               LD    L,(IX+6)
               LD    H,(IX+7)
               LD    DE,PARMS
               ADD   HL,DE
               LD    A,(HL)     ; ptr[PARMS]
               LD    (parms),A
               LD    DE,NAME-PARMS
               ADD   HL,DE
               LD    DE,noccargc+2
               CALL  streq
               LD    L,A
               LD    A,(IX+1)
               AND   A
               RRCA
               INC   L          ; L=vysledok streq
               DEC   L          ; A=pocet argumentov
               LD    H,0
               LD    L,A
               PUSH  HL
               JR    NZ,inlineargc

               CALL  loadargc
               LD    L,(IX+6)
               LD    H,(IX+7)
               LD    A,H
               OR    L
               JR    Z,volajstk
               LD    DE,NAME
               ADD   HL,DE
               PUSH  HL
               LD    HL,mov8
               CALL  ot
               POP   HL
               CALL  ol
               JR    volajstk1

inlineargc:    LD    HL,mov31
               CALL  ol
               LD    HL,mov31x
               CALL  ol
               JR    volajstk1

volajstk:      CALL  callstk     ; ptr=0
               LD    A,-1
               LD    (parms),A   ; AUTOMATIC no check
volajstk1:     POP   BC
               POP   IX
               POP   AF
               PUSH  BC
               LD    D,0
               LD    E,A
               LD    HL,(csp)
               ADD   HL,DE
               LD    A,YES
               CALL  modstk
               LD    (csp),HL
               LD    A,(usereg)
               AND   A
               JR    Z,t5
               LD    A,(pushreg)
               AND   A
               JR    Z,t5
               LD    A,(usereg)
               CP    1
               JR    NZ,oba2ix
               INC   HL       ; len ix
               INC   HL
               LD    (csp),HL
               LD    HL,t44
               CALL  ol
               JR    t5

oba2ix:        LD    DE,4     ; pop ix iy
               ADD   HL,DE
               LD    (csp),HL
               LD    HL,t4
               CALL  ol
               INC   HL
               CALL  ol

t5:            POP   HL
               POP   BC
               POP   BC
               POP   BC
               LD    A,(parms)
               CP    -1        ; variadic
               RET   Z         ; bez poctu parametrov
               CP    L
               RET   Z         ; inak musi suhlasit pocet params
               JP    badarg

rovna:         AND   A
               SBC   HL,BC
               ADD   HL,BC
               RET

dbltest:       PUSH  HL           ; BC =oper
               LD    HL,ffadd     ; hl =lval2
               CALL  rovna        ; de =lval1
               JR    Z,moz        ; vracia n:1:0 v reg. A
               LD    HL,ffsub     ; pokial ide sucet a odcitanie
               CALL  rovna        ; pointerov
               JR    Z,moz
               POP   HL
               JP    jedna        ; jedna = char = nerob nic

moz:           POP   HL
               PUSH  DE
               EX    (SP),IX
               LD    C,(IX+0)     ; BC=ptr
               LD    B,(IX+1)
               LD    A,B
               OR    C
               LD    A,(IX+4)
               EX    (SP),IX
               POP   DE
               JP    Z,jedna

               PUSH  AF
               EX    DE,HL
               LD    HL,IDENT2
               ADD   HL,BC
               LD    A,(HL)
               EX    DE,HL
               CP    FUNCTION
               JR    Z,badpo-1  ; ptr to fnc
               POP   AF

               BIT   7,A
               JR    NZ,isstru  ; OBSLUHA STRUCT
               AND   MASK+2     ; void allowed
               CP    CCHAR
               JP    Z,jedna
               CP    CVOID
               JP    Z,badpo
               AND   A
               JP    Z,jedna    ; not pointer
               CP    CINT
               JR    NZ,badpo   ; ptr to else -> error
               LD    DE,4
               ADD   HL,DE
               LD    A,(HL)
               AND   A
               JP    NZ,jedna   ; ide o premennu
               LD    A,2
               AND   A
               RET

isstru:        LD    DE,4       ; if lval2[2] return 1
               ADD   HL,DE
               LD    A,(HL)
               AND   A
               JP    NZ,jedna

doone:         LD    HL,MENOSTR ; return size(struct)
               ADD   HL,BC      ; bc=ptr
               CALL  hlhl
               LD    DE,ONE
               ADD   HL,DE
               LD    A,(HL)
               AND   A
               RET

               POP   AF
badpo:         CALL  warning    ; cvoid, cfunction
               DM    "fnc or void pointer in expression"
               NOP
               JP    nula

mreg:          CP    2
               JP    Z,doublereg
               CP    1
               RET   Z  ; char nic
               CALL  log+1
               RET   Z
               PUSH  AF         ; for 0 or hl>2
               CALL  pushrh
               POP   AF
               LD    L,A
               LD    H,0
               CALL  const2
               CALL  ffmult
               JP    popr

log:           LD    A,L
               CP    4
               JR    Z,k4
               CP    8
               JR    Z,k8
               CP    16
               JR    Z,k16
               CP    32
               RET   NZ
k32:           CALL  doublereg
k16:           CALL  doublereg
k8:            CALL  doublereg
k4:            CALL  doublereg
               CALL  doublereg
               XOR   A
               RET

result:        PUSH  HL      ; HL, DE
               PUSH  DE
               LD    BC,2*2
               ADD   HL,BC
               EX    DE,HL
               ADD   HL,BC
               EX    DE,HL
               LD    A,(HL)
               AND   A
               JR    Z,elze
               EX    DE,HL
               LD    A,(HL)
               AND   A
               EX    DE,HL
               JR    Z,elze
               LD    (HL),0  ; if != 0 then 0
               POP   DE      ; ak su pointre vysledok nieje point
               INC   HL
               INC   HL
               INC   HL
               LD    (HL),1  ; unsigned
               POP   HL
               RET

elze:          LD    A,(DE)
               AND   A
               POP   HL
               POP   DE
               RET   Z
               LD    BC,2*3+1 ; if lval2 != 0
               LDIR
               RET

step2:         LD    A,1     ; post
               JR    step+1

step:          XOR   A       ; pre
               LD    (stepf),A
               LD    (opera+1),HL     ; HL = adresa operacie
               LD    (opera6+1),HL    ; DE = lval
               PUSH  DE
               EX    (SP),IX
               LD    L,(IX+0)
               LD    H,(IX+1)
               LD    A,(HL)           ; a ident
               INC   HL
               LD    C,(HL)
               LD    B,(IX+4)       ; pointer  ??
               INC   B
               DEC   B
               JR    NZ,$+4
               LD    C,CCHAR
               LD    (IX+4),C       ; typ objektu char *

               LD    BC,IDENT2-1
               ADD   HL,BC
               LD    A,(HL)
               CP    FUNCTION       ; pointer to fnc
               CALL  Z,badpo

               LD    A,(IX+2)
               AND   A
               JR    Z,kono       ;kono

               LD    A,(IX+10)
               AND   A
               JR    Z,elze1

               PUSH  DE
               CALL  pushr
               POP   HL
               PUSH  HL
               CALL  rvalue
               LD    A,(stepf)
               AND   A
               PUSH  AF
               CALL  NZ,popr       ; swapstk
               POP   AF
               CALL  NZ,pushr
               CALL  skipsize
opera:         CALL  0
               LD    A,(stepf)
               AND   A
               CALL  Z,popr
               POP   HL
               POP   IX
               CALL  store
               LD    A,(stepf)
               AND   A
               CALL  NZ,poprh
               RET

elze1:         PUSH  DE
               CALL  move
               POP   DE
               LD    (IX+10),1

kono:          EX    DE,HL
               PUSH  HL
               CALL  rvalue
               LD    A,(stepf)
               AND   A
               CALL  NZ,pushr
               CALL  skipsize
opera6:        CALL  0
               POP   HL
               POP   IX
               CALL  store
               DB    62
stepf:         NOP
               AND   A
               CALL  NZ,poprh
               RET

skipsize:      LD    A,(IX+4)
               BIT   7,A
               JR    Z,ist0
               LD    C,(IX+0)
               LD    B,(IX+1)
               CALL  doone
               LD    L,A
               JR    ist1
ist0:          AND   MASK+2
               LD    HL,0
               CP    CVOID
               JR    Z,ist1
               INC   L
               CP    CCHAR
               JR    Z,ist1
               INC   L
ist1:          LD    A,L
               LD    H,0
               RET

testval:       PUSH  HL     ; v reg: DE
               PUSH  AF
               PUSH  DE
               EX    DE,HL
               LD    A,(HL)
               CP    VARIABLE
               JR    Z,erg
               CP    ARRAY
               JR    Z,erg
erg6:          PUSH  DE
               LD    DE,INFOBYTE
               ADD   HL,DE
               BIT   3,(HL)
               POP   DE
               JR    Z,testval2
               CALL  error
               DM    "member without struct or union"
               NOP
testval2:      POP   DE
               POP   AF
               POP   HL
               RET

erg:           INC   HL
               BIT   7,(HL)
               DEC   HL
               JR    Z,erg6
               CALL  error
               DM    "struct or union in expression"
               NOP
               JR    testval2

testconst:     PUSH  HL     ; v reg: DE
               PUSH  AF
               PUSH  DE
               LD    HL,INFOBYTE
               ADD   HL,DE
               BIT   6,(HL)
               JR    Z,erg-4
constan:       CALL  warning
               DM    "can't write to const"
               NOP
               JR    erg-4

store:         PUSH  HL
               EX    (SP),IX       ; hl=lval
               LD    A,(IX+2)
               AND   A
               LD    E,(IX+0)
               LD    D,(IX+1)
               EX    (SP),IX
               POP   HL
               CALL  testval
               CALL  testconst
               JP    Z,putmem
               JP    putstk

rvalue:        PUSH  HL          ; hl=lval
               EX    (SP),IX
               LD    E,(IX+0)
               LD    D,(IX+1)
               CALL  testval
               LD    A,D
               OR    E
               EX    (SP),IX
               POP   HL
               JP    Z,indirect  ; if lval[0] == 0
               PUSH  HL
               EX    (SP),IX
               LD    A,(IX+2)
               AND   A
               EX    (SP),IX     ;
               POP   HL
               JP    NZ,indirect
               JP    getmem

test:          LD    (paren),A         ; A, HL
               LD    (lbl),HL          ;
               LD    A,(paren)
               AND   A
               LD    A,"("
               CALL  NZ,needtoken

whil2:         LD    HL,befo
               LD    DE,srt
               CALL  setstage

               LD    HL,lval
               CALL  heir1

               LD    HL,lval
               CALL  NZ,rvalue

               LD    A,","
               CALL  matches
               JR    NZ,nasw       ; operator comma

               LD    HL,(befo)
               LD    DE,(srt)
               CALL  clearstage    ; vysli obsah bufera
               JR    whil2

nasw:          LD    A,(paren)
               AND   A
               LD    A,")"
               CALL  NZ,needtoken

               LD    A,(lval+6)
               AND   A
               JR    Z,va7

               LD    HL,(befo)     ; if const expr
               LD    DE,0
               CALL  clearstage
               LD    HL,(lval+8)
               LD    A,H
               OR    L
               RET   NZ            ; while (1) atd bez testu
               LD    HL,(lbl)      ; inak skoc vzdy
               JP    jump

va7:           LD    HL,(lval+14)
               LD    A,H
               OR    L
               JP    Z,dfg
               LD    HL,(lval+12)
               LD    (oper),HL
               LD    DE,(lbl)
               LD    BC,ffeq
               CALL  rovna
               JR    Z,eqa
               LD    BC,ule
               CALL  rovna
               JR    NZ,oth1

eqa:           LD    HL,eq0
               CALL  zerojump
               JP    elze3

oth1:          LD    BC,ffne
               CALL  rovna
               JR    Z,eqa1

               LD    BC,ugt
               CALL  rovna
               JR    NZ,oth2

eqa1:          LD    HL,ne0
               CALL  zerojump
               JP    elze3

oth2:          LD    BC,ffgt
               CALL  rovna
               JR    NZ,oth3
               LD    HL,gt0
               CALL  zerojump
               JP    elze3

oth3:          LD    BC,ffge
               CALL  rovna
               JR    NZ,oth4
               LD    HL,ge0
               CALL  zerojump
               JP    elze3

oth4:          LD    BC,uge
               CALL  rovna
               JR    NZ,oth5
               LD    HL,(lval+14)
               LD    DE,0
               CALL  clearstage
               JP    elze3

oth5:          LD    BC,fflt
               CALL  rovna
               JR    NZ,oth6
               LD    HL,lt0
               CALL  zerojump
               JP    elze3

oth6:          LD    BC,ult
               CALL  rovna
               JR    NZ,oth7
               LD    HL,ult0
               CALL  zerojump
               JR    elze3

oth7:          LD    BC,ffle
               CALL  rovna
               JR    NZ,dfg
               LD    HL,le0
               CALL  zerojump
               JR    elze3

dfg:           LD    HL,(lbl)
               CALL  testjump

elze3:         LD    HL,(befo)
               LD    DE,(srt)
               JP    clearstage

constexpr:     PUSH  HL       ; HL = adr premennej
               LD    HL,befo1
               LD    DE,star1
               CALL  setstage
               LD    HL,autv
               POP   DE
               CALL  expression
               LD    HL,(befo1)
               LD    DE,0
               CALL  clearstage
               LD    HL,(autv)
               LD    A,H
               OR    L
               RET   NZ
               CALL  error
               DM    "must be constant expresion"
               NOP
               JP    nula

const:         PUSH  HL
               CALL  immed
               JR    const2+4

const3:        PUSH  HL
               CALL  immed3
               JR    const2+4

const2:        PUSH  HL
               CALL  immed2
               POP   HL
               CALL  outdec
               JP    nl

expl:          PUSH  AF
               CALL  warning
               DM    "explicit long constant isn't implemented"
               NOP
               CALL  preskoc
               POP   AF
               RET

expu:          LD    (IX+7),1  ; explicit unsigned
               CALL  preskoc
               RET

constant:      PUSH  HL        ; hl=lval
               EX    (SP),IX
               LD    (IX+6),1  ; 1=if OK
               LD    (IX+7),0
               LD    DE,4*2
               ADD   HL,DE
               LD    (cons),HL
               CALL  number
               JR    Z,nonum

               LD    HL,(lptr)
               LD    A,(HL)
               AND   &DF

               CP    "L"
               CALL  Z,expl

               CP    "U"
               CALL  Z,expu

               CALL  immed
               JR    numbs

nonum:         LD    HL,(cons)
               CALL  pstr
               JR    Z,nostx
               CALL  immed
               JR    numbs

nahrada:       DB    ARRAY
               DB    CUCHAR
               DB    STATIC
               DW    0
               DB    &47            ; const defined used
               DB    1
               DW    0,0
               DB    1
               DW    0,0
               DM    "const"
               NOP

nostx:         LD    HL,(cons)
               CALL  qstr
               JR    Z,blbost
               LD    (IX+6),0
               CALL  immed
               LD    HL,nahrada
               CALL  copysym
               LD    (IX+0),L  ; lval[0]=ptr;
               LD    (IX+1),H
               LD    HL,(litlab)
               CALL  printlabel
               LD    A,(IX+8)
               OR    (IX+9)
               JR    Z,numbs1

               LD    A,"+"
               CALL  outbyte

numbs:         LD    L,(IX+8)
               LD    H,(IX+9)
               CALL  outdec
numbs1:        CALL  nl
               POP   IX
               JP    jedna

blbost:        POP   IX
               JP    nula

number:        PUSH  HL        ; hl= lval
               LD    HL,(lptr)
               EX    DE,HL     ; hl=retazec

SEE1:          LD    A,(DE)
               CP    " "
               INC   DE
               JR    Z,SEE1
               DEC   DE

               CP    "-"
               LD    B,-1
               INC   DE
               JR    Z,signum
               DEC   DE
               LD    B,0
               CALL  isnum
               POP   HL
               JP    NC,nula       ; nejde o cislo
               PUSH  HL

signum:        PUSH  BC
               CALL  READ1
               JR    C,errnum
               PUSH  HL
               EX    DE,HL
               CALL  cbum1
               POP   HL
               POP   AF
               INC   A
               CALL  Z,CCNEG
               EX    DE,HL
               POP   HL
               LD    (HL),E
               INC   HL
               LD    (HL),D
               JP    jedna

errnum:        POP   HL
               POP   HL
               JP    nula

READ1:         LD    A,(DE)
               LD    HL,0
               LD    B,10
               CP    "0"
               JR    NZ,DECAD
               LD    B,8
               INC   DE
               LD    A,(DE)
               SET   5,A
               CP    "x"
               JR    Z,dead
               CP    "b"
               JR    NZ,DECAD
               LD    B,2
               INC   DE
               JR    DECAD
dead:          INC   DE
               LD    B,16

DECAD:         LD    A,(DE)
               CP    14
               CCF
               RET   NC
               CALL  ishex
               RET   NC               ; noalpha
               SUB   "0"
               CP    10
               JR    C,NUM4
               SUB   "A"-"9"-1
NUM4:          CP    16
               RET   NC

               INC   DE
               PUSH  DE
               EX    DE,HL
               LD    HL,0
               PUSH  BC
NUM5:          ADD   HL,DE
               CALL  C,overflow
               DJNZ  NUM5
               LD    D,0
               LD    E,A
               ADD   HL,DE
               CALL  C,overflow
               POP   BC
               POP   DE
               JR    DECAD

overflow:      PUSH  BC
               PUSH  DE
               PUSH  HL
               PUSH  AF
               CALL  warning
               DM    "arithmetic overflow"
               NOP
               POP   AF
               POP   HL
               POP   DE
               POP   BC
               RET

address:
               LD    DE,INFOBYTE
               ADD   HL,DE
               LD    A,(HL)
               SBC   HL,DE
               BIT   3,A
               RET   NZ         ; struct item nema addresu
               PUSH  HL
               PUSH  AF
               CALL  immed
               POP   AF
               POP   HL
               BIT   4,A
               JR    Z,address2
               LD    DE,OFFSET  ; autostatic cez zameno
               ADD   HL,DE
               CALL  hlhl
               CALL  printlabel
               JP    nl
address2:
               LD    DE,NAME
               ADD   HL,DE
               JP    ol

pstr:          PUSH  HL             ; HL ukazuje do pola
               CALL  match
               DB    "'"
               POP   HL
               JP    NZ,nula
               PUSH  HL
               LD    HL,0

a8:            LD    A,(ch)
               CP    "'"
               JR    Z,evalu

               PUSH  HL
               CALL  litchar
               POP   HL
               LD    H,L
               LD    L,A
               JR    a8

evalu:         PUSH  HL
               CALL  inbyte  ; gch
               POP   DE
               POP   HL
               LD    (HL),E
               INC   HL
               LD    (HL),D
               JP    jedna

qstr:          PUSH  HL         ; HL ukazuje do pola
               LD    A,(quote)
               CALL  matches
               POP   HL
               JP    NZ,nula
               LD    DE,(litptr)
               LD    (HL),E
               INC   HL
               LD    (HL),D

a9:            LD    A,(ch)
               CP    34
               JR    Z,b0
               AND   A
               JR    Z,b0
               CALL  litchar
               LD    DE,1
               LD    H,0
               LD    L,A
               CALL  stowlit
               JR    a9

b0:            CALL  inbyte        ; gch
               LD    DE,(litptr)
               INC   DE
               LD    (litptr),DE
               JP    jedna

stowlit:       EX    DE,HL  ; size
               PUSH  DE     ; value

               LD    DE,(litptr)
               PUSH  DE
               ADD   HL,DE
               LD    (litptr),HL

               LD    BC,LITMAX
               SBC   HL,BC
               JR    C,oklit

               CALL  error
               DM    "literal queue overflow"
               DB    0
               JP    abort
oklit:         POP   HL
               LD    DE,litq
               ADD   HL,DE
               POP   DE
               LD    (HL),E
               INC   HL
               LD    (HL),D
               RET

litchar:       LD    A,(ch)  ; inbyte = gch
               CP    "\"
               JP    NZ,gch
               LD    A,(nch)
               AND   A
               JP    Z,gch

               CALL  gch
               LD    A,(ch)
               LD    B,"\"
               CP    "\"
               JP    Z,rre

               LD    B,22
               CP    "a"
               JP    Z,rre

               LD    B,34
               CP    34
               JP    Z,rre

               LD    B,"'"
               CP    "'"
               JP    Z,rre

               LD    B,13
               CP    "n"
               JR    Z,rre

               LD    B,23
               CP    "t"
               JR    Z,rre

               LD    B,8
               CP    "b"
               JR    Z,rre

               LD    B,16
               CP    "i"
               JR    Z,rre

               LD    B,17
               CP    "p"
               JR    Z,rre

               LD    B,12
               CP    "f"
               JR    Z,rre

               CP    "x"
               JR    Z,hex
               CP    "X"
               JR    Z,hex

               CP    "0"        ; nemen ak nieje 0
               LD    B,A        ; 0xff a 255 ... dorobit
               JR    C,rre
               CP    "8"
               JR    NC,rre

               LD    B,3
               LD    HL,0

oct:           PUSH  BC
               PUSH  HL
               LD    A,(ch)
               CALL  isoct
               JR    NC,nepl
               SUB   "0"
               POP   HL
               RL    L
               RL    L  ; L=L * 8
               RL    L
               ADD   L
               LD    L,A
               PUSH  HL
               CALL  gch
               POP   HL
               POP   BC
               DJNZ  oct

plat:          LD    A,L
               RET

nepl:          POP   HL
               POP   BC
               JR    plat

rre:           PUSH  BC
               CALL  gch
               POP   BC
               LD    A,B
               RET

hex:           CALL  gch
               LD    B,2       ; preskoc X, x
               LD    HL,0
hex2:          PUSH  BC
               PUSH  HL
               LD    A,(ch)
               CALL  an
               JR    NC,nepl
               SUB   "0"
               CP    10
               JR    C,isk
               SUB   7
               CP    16
               JR    C,isk
               SUB   " "
               JR    C,nepl
               CP    16
               JR    NC,nepl
isk:           POP   HL
               AND   A
               RL    L
               RL    H
               RL    L  ; L=L * 8
               RL    H
               RL    L
               RL    H
               RL    L
               RL    H
               ADD   L
               LD    L,A
               JR    NC,$+3
               INC   H
               PUSH  HL
               CALL  gch
               POP   HL
               POP   BC
               DJNZ  hex2
               JR    plat

header:        LD    A,(startcode)
               AND   A
               RET   Z

               LD    HL,prolog
               CALL  OUTBUF
               CALL  OUTBUF
               CALL  OUTBUF
               LD    A,(svflag)
               AND   A
               JR    Z,nosv

               LD    HL,svprolog
               CALL  OUTBUF
               CALL  OUTBUF
               CALL  OUTBUF
               LD    A,"2"
               LD    (pro7+7),A
               LD    HL,pro5
               JR    sv

nosv:          CALL  ot
               LD    HL,(myorg)
               CALL  outdec
               CALL  nl
               LD    A,(smartcode)
               AND   A
               LD    A," "
               JR    Z,$+4
               LD    A,"!"
               LD    (pro7+7),A
               LD    HL,pro1
               CALL  OUTBUF
               CALL  OUTBUF
               CALL  OUTBUF
sv:            CALL  OUTBUF
               CALL  OUTBUF

               LD    HL,pro4
               CALL  ot
               LD    HL,(codesp)
               CALL  outdec
               CALL  nl

               LD    HL,prox
               CALL  OUTBUF
               CALL  OUTBUF
               CALL  OUTBUF
               CALL  OUTBUF
               RET

trailer:
               LD    HL,endofcode
               CALL  OUTBUF
               RET

loadargc:      LD    A,(parms)
               CP    -1
               JR    Z,li       ; nieje
               LD    A,(argc)
               AND   A          ; variadic a automatic are -1
               RET   Z          ; prototyp ma pevny pocet params

li:            LD    A,L
               AND   A
               JR    Z,xora
               PUSH  HL
               LD    HL,mov30
               CALL  ot
               POP   HL
               CALL  outdec
               JP    nl

xora:          LD    HL,mov21
               JP    ol

entry:         LD    HL,ssname
               CALL  ot
               JP    col

indirect:      INC   HL       ;hl=lval
               INC   HL
               LD    A,(HL)   ; lval(2)
               AND   MASK
               CP    CCHAR
               JR    NZ,indi
               LD    A,(HL)
               CP    CCHAR
               JR    NZ,unin
               LD    A,(fast) ; signed char
               AND   A
               JR    NZ,rozlo1
               CALL  ffcall
               DM    "CCGCHAR"
               DB    0
               RET

rozlo1:        LD    HL,ccgchar
               CALL  ol
               INC   HL
               CALL  ol
               INC   HL
               CALL  ol
               INC   HL
               JP    ol

unin:          LD    HL,mov311       ; pre pripad uchar
               CALL  ol
               INC   HL
               CALL  ol
               RET

indi:          LD    A,(fast)
               AND   A
               JR    NZ,rozlo2
               CALL  ffcall
               DM    "CCGINT"
               DB    0
               RET

rozlo2:        LD    HL,ccgint
               CALL  ol
               INC   HL
               CALL  ol
               INC   HL
               CALL  ol
               INC   HL
               JP    ol

getloc:        LD    DE,OFFSET     ; hl=table entry
               LD    A,(HL)
               CP    FUNCTION
               RET   Z             ; okrem FUNCTION
               ADD   HL,DE
               CALL  hlhl
               BIT   7,H
               JR    NZ,local
               EX    DE,HL
               LD    HL,(argstk)
               AND   A
               SBC   HL,DE
local:         LD    DE,(csp)
               AND   A
               SBC   HL,DE
               CALL  const
               LD    HL,mov28
               JP    ol

prtname:       LD    L,(IX+0)      ; tlac meno podla triedy
               LD    H,(IX+1)
               LD    DE,INFOBYTE
               ADD   HL,DE
               BIT   4,(HL)
               JR    Z,cezsym
               DEC   HL
               DEC   HL
               CALL  hlhl
               JP    printlabel

cezsym:        LD    DE,NAME-INFOBYTE
               ADD   HL,DE
               JP    ot

getmem:        PUSH  HL         ;hl=lval
               EX    (SP),IX
               LD    L,(IX+0)
               LD    H,(IX+1)

               CALL  isreg      ; load iy
               JR    Z,zregs

               LD    A,POINTER
               CP    (HL)
               JR    Z,iso
               INC   HL
               LD    A,(HL)
               AND   MASK
               CP    CCHAR
               JR    NZ,iso
               LD    A,(HL)
               BIT   0,A
               JR    NZ,unsch
               LD    HL,lda
               CALL  ot
               CALL  prtname
               LD    A,")"
               CALL  outbyte  ; ld a,(addr)
               CALL  nl       ; call CCSXT
               CALL  ffcall
               DM    "CCSXT"  ; PREVED konverziu signed
               DB    0
               POP   IX
               RET

unsch:         LD    HL,lda1  ; ld hl,(addr)
               CALL  ot       ; ld h,0
               CALL  prtname
               LD    A,")"
               CALL  outbyte
               CALL  nl
               LD    HL,mov31
               CALL  ol
iso2:          POP   IX
               RET

iso:           LD    HL,lda1
               CALL  ot
               CALL  prtname
               LD    A,")"
               CALL  outbyte
               CALL  nl
               JR    iso2

zregs:         DEC   A
               JR    NZ,zreg1

zreg0:         LD    HL,loadix    ; put
               JR    doreg1+3
zreg1:         LD    HL,loadiy
               JR    doreg1+3

doregs:        DEC   A
               JR    NZ,doreg1

doreg0:        LD    HL,saveix    ; get
               JR    $+5
doreg1:        LD    HL,saveiy
               CALL  ol
               INC   HL
               CALL  ol
               JR    iso2

isreg:         PUSH  HL         ; Z if REGISTER
               INC   HL         ; A = 0 for ix
               INC   HL         ;  or 1 for iy
               LD    A,(HL)
               CP    REGISTER
               LD    DE,PARMS-2
               ADD   HL,DE
               LD    A,(HL)
               POP   HL
               RET

putmem:        PUSH  HL         ;hl=lval
               EX    (SP),IX
               LD    L,(IX+0)
               LD    H,(IX+1)

               CALL  isreg      ; save iy
               JR    Z,doregs

               LD    A,POINTER
               CP    (HL)
               SCF
               JR    Z,isol
               INC   HL
               LD    A,(HL)
               AND   MASK
               CP    CCHAR
               SCF
               JR    NZ,isol

               LD    HL,sta1
               CALL  ol
               AND   A

isol:          PUSH  AF
               LD    HL,sta
               CALL  ot
               CALL  prtname
               POP   AF
               LD    HL,sta3
               JR    C,$+5
               LD    HL,sta2
               CALL  ol
               JP    iso2

putstk:        INC   HL             ;hl=lval
               INC   HL
               LD    A,(HL)
               AND   MASK
               CP    CCHAR
               JR    NZ,pint

               LD    HL,mov0
               CALL  ol
               INC   HL
               JP    ol

pint:          LD    A,(fast)
               AND   A
               JR    NZ,rozlo3
               CALL  ffcall
               DM    "CCPINT"
               NOP
               RET

rozlo3:        LD    HL,ccpint
               CALL  ol
               INC   HL
               CALL  ol
               INC   HL
               CALL  ol
               INC   HL
               CALL  ol
               INC   HL
               JP    ol

move:          LD    HL,mov1
               CALL  ol
               INC   HL
               JP    ol

swap:          LD    HL,mov2
               JP    ol

swap2:         LD    HL,mov32
               JP    ol

immed:         LD    HL,mov3
               JP    ot

immed2:        LD    HL,mov4
               JP    ot

immed3:        LD    HL,mov40
               JP    ot

pushrh:        LD    HL,mov231
               JR    pushr+3
pushr:         LD    HL,mov5
               CALL  ol
               LD    HL,(csp)
               DEC   HL
               DEC   HL
               LD    (csp),HL
               RET

poprh:         LD    HL,mov22
               JR    popr+3
popr:          LD    HL,mov6
               CALL  ol
               LD    HL,(csp)
               INC   HL
               INC   HL
               LD    (csp),HL
               RET

smartpop:      LD    BC,10    ; HL = ukaztel lval
               ADD   HL,BC    ; DE = start
               LD    A,(HL)
               AND   A
               JR    NZ,popr

unpush:        LD    HL,mov2
               LD    BC,8
               LDIR
               LD    A,13
               LD    (DE),A
               INC   DE
               LD    (dest),DE
               LD    HL,(stagenext)
               LD    (sour),HL

cc00:          LD    HL,(sour)
               DEC   HL
               LD    (sour),HL
               EX    DE,HL
               LD    HL,(dest)
               AND   A
               SBC   HL,DE
               JR    NC,endpush

               EX    DE,HL
               LD    DE,mov28
               CALL  streq
               JR    Z,cc00   ; nenasiel, loop

               LD    HL,(sour)
               DEC   HL
               LD    (sour),HL
               LD    A,BPW
               LD    (iii),A

cc01:          LD    HL,(sour)
               DEC   HL
               LD    (sour),HL
               LD    A,(HL)
               CALL  isnum
               JR    NC,cc00

               EX    DE,HL
               LD    HL,iii
               SUB   (HL)
               LD    (DE),A
               CP    "0"
               JR    NC,cc02

               ADD   10
               LD    (DE),A
               LD    (HL),1
               JR    cc01

cc02:          LD    (HL),0
               JR    cc01

endpush:       LD    HL,(csp)
               INC   HL
               INC   HL
               LD    (csp),HL
               RET                ; HL = detto

sw:            CALL  ffcall
               DM    "CCSWITCH"
               NOP
               RET

callesc:       LD    A,(esc)
               AND   A
               RET   Z

               CALL  ffcall
               DM    "_ESCAPE_TEST"
               NOP
               RET
ffcall:
               LD    HL,mov8
               CALL  ot
               POP   HL
               CALL  ol
               INC   HL
               JP    (HL)

saver:         LD    A,(intf)
               AND   A
               RET   NZ
               LD    HL,t1
               JP    os

ffret:         LD    HL,mov9
               LD    A,(intf)
               AND   A
               JP    NZ,ol
               LD    HL,t2
               JP    os

callstk:       CALL  ffcall
               DM    "CCJUMP"
               NOP
               RET

ccmodify:      LD    HL,ccjmp
               JP    ol

jump:          PUSH  HL
               LD    HL,mov10
jump3:         CALL  ot
               POP   HL
               CALL  printlabel
               JP    nl

testjump:      PUSH  HL
               LD    HL,mov11
               CALL  ol
               INC   HL
               CALL  ol
               INC   HL
               JR    jump3

zerojump:      PUSH  HL           ; HL operacia
               PUSH  DE           ; DE navestie
               LD    HL,(lval+14)
               LD    DE,0
               CALL  clearstage
               POP   HL         ; z HL
               RET             ; skok na (HL)

defstorage:    CP    1
               JR    NZ,dwo
               LD    HL,mov12
               JP    ot
dwo:           CP    2
               JR    NZ,tro
dodefw:        LD    HL,mov12+4
               JP    ot
tro:           LD    HL,mov12+8
               JP    ot

point:         LD    HL,mov13
               JP    ol

k1:            DW    0
modstk:        PUSH  HL          ; HL = newsp
               AND   A
               PUSH  AF          ; A  = save BOOL
               LD    DE,(csp)
               AND   A
               SBC   HL,DE
               LD    (k1),HL
               JR    NZ,poka
fmof:          POP   AF
               POP   HL
               RET

poka:          BIT   7,H
               JR    NZ,ino
               LD    DE,7
               AND   A
               SBC   HL,DE
               ADD   HL,DE
               JR    NC,ino
               BIT   0,L
               RES   0,L
               PUSH  HL
               LD    HL,mov26
               CALL  NZ,ol
               POP   HL
               LD    (k1),HL
whil4:         LD    A,H
               OR    L
               JR    Z,fmof
               PUSH  HL
               LD    HL,mov24
               CALL  ol
               POP   HL
               DEC   HL
               DEC   HL
               JR    whil4
ino:           LD    DE,-7     ; stack sa dekrementuje
               AND   A
               SBC   HL,DE
               ADD   HL,DE
               JR    C,ino1
               BIT   0,L
               JR    Z,$+3
               INC   HL
               PUSH  HL
               LD    HL,mov27
               CALL  NZ,ol
               POP   HL
               LD    (k1),HL
whil5:         LD    A,H
               OR    L
               JR    Z,fmof
               PUSH  HL
               LD    HL,mov25
               CALL  ol
               POP   HL
               INC   HL
               INC   HL
               JR    whil5

ino1:          POP   AF
               PUSH  AF
               CALL  NZ,swap2
               LD    HL,(k1)
               CALL  const
               LD    HL,mov28
               CALL  ol
               INC   HL
               CALL  ol
               POP   AF
               CALL  NZ,swap2
               POP   HL
               RET

doublereg:     LD    HL,mov14
               JP    ol



ffadd:         LD    HL,mov15
               JP    ol

ffsub:         LD    HL,mov16
               CALL  ol
               INC   HL
               CALL  ol
               INC   HL
               JP    ol

ffmult:        CALL  ffcall
               DM    "CCMUL"
               NOP
               RET

ffumult:       CALL  ffcall
               DM    "CCUMUL"
               NOP
               RET

ffdiv:         CALL  ffcall
               DM    "CCDIV"
               NOP
               RET

ffmod:         CALL  ffdiv
               JP    swap

ffudiv:        CALL  ffcall
               DM    "CCUDIV"
               NOP
               RET

ffumod:        CALL  ffudiv
               JP    swap

ffor:          CALL  ffcall
               DM    "CCOR"
               NOP
               RET

ffxor:         CALL  ffcall
               DM    "CCXOR"
               NOP
               RET

ffand:         CALL  ffcall
               DM    "CCAND"
               NOP
               RET

lneg:          CALL  ffcall
               DM    "CCLNEG"
               NOP
               RET

ffasr:         CALL  ffcall
               DM    "CCASR"
               NOP
               RET

ffasl:         CALL  ffcall
               DM    "CCASL"
               NOP
               RET

negate:        CALL  ffcall
               DM    "CCNEG"
               NOP
               RET

com:           CALL  ffcall
               DM    "CCCOM"
               NOP
               RET

incr:          CP    4
               JR    NC,binc
incr1:         DEC   L
               RET   M
               PUSH  HL
               LD    HL,mov17
               CALL  ol
               POP   HL
               JR    incr1
binc:
               LD    H,0
               CALL  const3
               LD    HL,mov41
               CALL  ol
               RET

decr:          CP    4      ; velkost objektu
               JR    NC,bdec
decr1:         DEC   L
               RET   M
               PUSH  HL
               LD    HL,mov18
               CALL  ol
               POP   HL
               JR    decr1
bdec:          PUSH  HL
               CALL  immed3
               POP   HL
               LD    H,0
               LD    DE,0
               EX    DE,HL
               AND   A
               SBC   HL,DE
               CALL  outdec
               CALL  nl
               LD    HL,mov41
               CALL  ol
               RET

eq0:           PUSH  HL
               LD    HL,mov19
               CALL  ol
               INC   HL
               CALL  ol
               INC   HL
               CALL  ot
               POP   HL
               CALL  printlabel
               JP    nl

ne0:           JP    testjump

fflt:          CALL  ffcall    ; less than ..
               DM    "WRELOP"
               NOP
fflt1:         CALL  ostr
               DM    "ld hl,1"
               NOP
               CALL  ostr
               DM    "jp m,$+4"
               NOP
               CALL  ostr
               DM    "dec l"
               NOP
               RET

ffgt:          CALL  ffcall    ; great than ..
               DM    "WRELOP+1"
               NOP
               JR    fflt1

ffeq:          CALL  ffsub        ; rovne
               CALL  ostr
               DM    "ld hl,1"
               NOP
               CALL  ostr
               DM    "jr z,$+3"
               NOP
               CALL  ostr
               DM    "dec l"
               NOP
               RET

ffne:          CALL  ffsub        ;rozne
               CALL  ostr
               DM    "ld hl,1"
               NOP
               CALL  ostr
               DM    "jr nz,$+3"
               NOP
               CALL  ostr
               DM    "dec l"
               NOP
               RET

ffle:          CALL  ffcall    ; less than ..
               DM    "WRELOP+1"
               NOP
ffle1:         CALL  ostr
               DM    "ld hl,1"
               NOP
               CALL  ostr
               DM    "jp p,$+4"
               NOP
               CALL  ostr
               DM    "dec l"
               NOP
               RET

ffge:          CALL  ffcall    ; great than ..
               DM    "WRELOP"
               NOP
               JR    ffle1



ult:           CALL  ffcall    ; less than ..
               DM    "WRELOP"
               NOP
ult1:          CALL  ostr
               DM    "ld hl,1"
               NOP
               CALL  ostr
               DM    "jr c,$+3"
               NOP
               CALL  ostr
               DM    "dec l"
               NOP
               RET

ugt:           CALL  ffcall    ; great than ..
               DM    "WRELOP+1"
               NOP
               JR    ult1

ule:           CALL  ffcall    ; less than ..
               DM    "WRELOP+1"
               NOP
ule1:          CALL  ostr
               DM    "ld hl,1"
               NOP
               CALL  ostr
               DM    "jr nc,$+3"
               NOP
               CALL  ostr
               DM    "dec l"
               NOP
               RET

uge:           CALL  ffcall    ; great than ..
               DM    "WRELOP"
               NOP
               JR    ule1

lt0:           PUSH  HL
lt00:          LD    HL,mov20
               CALL  ol
               INC   HL
               CALL  ol
               INC   HL
               CALL  ot
               POP   HL
               CALL  printlabel
               JP    nl

le0:           PUSH  HL
               LD    HL,mov11
               CALL  ol
               INC   HL
               CALL  ol

               LD    HL,mov21
               CALL  ol
               JR    lt00

gt0:           PUSH  HL
               LD    HL,mov22
               CALL  ol
               INC   HL
               CALL  ol
               INC   HL
               CALL  ot

               POP   HL
               PUSH  HL
               CALL  printlabel
               CALL  nl

               LD    HL,mov111
               CALL  ol
               INC   HL
               CALL  ot
               POP   HL
               CALL  printlabel
               JP    nl

ge0:           PUSH  HL
               LD    HL,mov22
               CALL  ol
               INC   HL
               CALL  ol
               INC   HL
               CALL  ot
               POP   HL
               CALL  printlabel
               JP    nl
ult0:          JP    jump

peephole:      XOR   A
               EX    AF,AF'
               CALL  first
               LD    A,(optimize)
               AND   A
               CALL  Z,second    ; 1 = rychly kod
               EX    AF,AF'
               CALL  Z,OUTBUF    ; neposielalo sa
               LD    A,(HL)
               AND   A
               RET   Z           ; koniec bufera
               JR    peephole

first:         LD    DE,4
               PUSH  HL
               ADD   HL,DE
               LD    A,(HL)
               POP   HL
               CP    "l"
               RET   NZ

               PUSH  HL
               LD    DE,pe0
               CALL  streq
               JR    Z,notfo

               POP   HL
               LD    D,0
               LD    E,A
               ADD   HL,DE
               PUSH  HL
               LD    DE,mov2
               CALL  streq
               POP   HL
               JR    Z,bezde
               LD    D,0
               LD    E,A
               ADD   HL,DE
               PUSH  HL
               CALL  pp2

first1:        POP   HL
               EX    AF,AF'
               INC   A
               EX    AF,AF'
               RET

bezde:         PUSH  HL
               CALL  pp1
               JR    first1

locald:        PUSH  HL
               LD    DE,19
               ADD   HL,DE
               LD    A,(HL)
               CP    "e"
               POP   HL
               JP    NZ,xnot2   ; musi nasledovat ex de,hl

               PUSH  HL
               ADD   HL,DE
               LD    DE,mov2
               CALL  streq
               JR    Z,nold
               INC   HL
               LD    (adrs),HL
               LD    DE,mov3
               CALL  streq
               JR    Z,nold

               LD    A,14
               CP    (HL)
               INC   HL
               JR    C,$-2

               LD    DE,x98
               CALL  streq
               JR    Z,nold

               POP   AF
               PUSH  HL
               LD    A,C
               AND   A
               PUSH  AF
               LD    HL,t22
               CALL  NZ,OUTBUF
               LD    HL,t2
               CALL  OUTBUF
               LD    HL,(adrs)
               CALL  OUTBUF
               LD    HL,t11
               CALL  OUTBUF
               POP   AF
               LD    HL,t111
               CALL  NZ,OUTBUF
               JP    first1

nold:          POP   HL
               JR    xnot2

notfo:         POP   HL
               LD    A,B
               CP    20
               LD    C,0
               JR    Z,locald
               PUSH  HL
               LD    DE,pe1
               CALL  streq
               POP   HL
               JR    Z,xnot

               LD    D,0
               LD    E,A
               ADD   HL,DE
               PUSH  HL
               LD    DE,mov2
               CALL  streq
               POP   HL
               JR    Z,bezde1
               LD    D,0
               LD    E,A
               ADD   HL,DE
               PUSH  HL
               LD    HL,pp2
               CALL  pp3
               JP    first1

bezde1:        PUSH  HL
               LD    HL,pp1
               CALL  pp3
               JP    first1

xnot:          LD    A,B
               CP    20
               LD    C,1
               JP    Z,locald

xnot2:         PUSH  HL
               LD    DE,mov3
               CALL  streq         ; hladaj ld hl,
               EX    DE,HL
               POP   HL
               RET   Z

               PUSH  HL            ; ld hl,xxx sekcia !
               EX    DE,HL
               LD    A,(HL)
               LD    (oadd+2),A
               LD    A,14
               CP    (HL)
               INC   HL
               JR    C,$-2
               LD    (adrp),HL   ;pridavacia
               LD    (adrs),HL

               LD    A,(HL)
               CP    "e"
               JR    NZ,oaddsp5
               LD    DE,mov2
               CALL  streq
               EX    DE,HL
               POP   HL
               JR    Z,oaddsp
               EX    DE,HL       ; ex de,hl
               INC   HL
               PUSH  HL
               EX    DE,HL
               PUSH  HL
               INC   HL
               INC   HL
               INC   HL
               LD    (HL),"d"
               INC   HL
               LD    (HL),"e"
               POP   HL
               CALL  OUTBUF
               JP    first1

oaddsp:        PUSH  HL
               LD    HL,(adrs)
               LD    A,(HL)
oaddsp5:       CP    " "
               JR    NZ,oadd2
               LD    DE,mov28
               CALL  streq
               EX    DE,HL
               POP   HL
               JR    Z,oadd

               PUSH  HL
               EX    DE,HL     ;de > _add hl,sp, hl > ld sp,hl
               INC   HL
               LD    (adrs),HL
               CALL  testadd
               POP   HL
               RET   NZ

               PUSH  HL
               CALL  oad4
               CALL  testadd
               JR    NZ,nospl
               CALL  oad4
               CALL  testadd
               JR    NZ,nospl
               CALL  oad4
nospl:         POP   HL
               CALL  OUTBUF
               LD    HL,pe2
               CALL  OUTBUF
               EX    AF,AF'
               OR    H
               EX    AF,AF'
               LD    HL,(adrs)
               RET

oadd2:         POP   HL
oadd:          LD    B,A
               LD    A,0
               CP    "("
               RET   Z

               LD    A,"l"
               CP    B
               JR    NZ,oad7
               PUSH  HL
oad2:          CALL  testadd
               JR    Z,oad3
               POP   HL

oad7:          CALL  dir
               EX    AF,AF'
               PUSH  AF
               EX    AF,AF'
               POP   AF
               RET   Z
               CALL  OUTBUF
               LD    HL,(adrs)
               RET

oad3:          CALL  oad4
               JR    oad2

oad4:          LD    HL,(adrp)
               DEC   HL
               LD    (HL),"+"
               INC   HL
               EX    AF,AF'
               OR    H
               EX    AF,AF'

               LD    A,(DE)
               LD    (HL),A
               INC   DE
               INC   HL
               CP    13
               JR    NZ,$-6
               LD    (adrp),HL
               RET

dir:           PUSH  HL
               LD    HL,(adrs)
               LD    DE,x99
               CALL  streq
               JR    NZ,dir9
               LD    HL,(adrs)
               LD    DE,mov311
               CALL  streq
               INC   HL
               JR    NZ,dir9

               LD    HL,(adrs)  ; ex hl,de
               LD    DE,mov2
               CALL  streq
               INC   HL
               EX    DE,HL
               POP   HL
               RET   Z

               PUSH  HL
               LD    (adrs),DE
               INC   HL
               INC   HL
               INC   HL
               LD    (HL),"d"
               INC   HL
               LD    (HL),"e"
               EX    AF,AF'
               OR    H
               EX    AF,AF'
               POP   HL
               RET

dir9:          LD    (adrs),HL
               POP   HL
               PUSH  HL
               LD    A,13
               CP    (HL)
               INC   HL
               JR    NZ,$-2

               INC   HL
               LD    (HL),13
               DEC   HL
               LD    (HL),")"
               DEC   HL
               LD    E,L
               LD    D,H
               DEC   HL

               LD    A,(HL)
               CP    ","
               JR    Z,$+6
               LDD
               JR    $-7

               EX    DE,HL
               LD    (HL),"("
               EX    AF,AF'
               OR    H
               EX    AF,AF'
               POP   HL
               RET

testadd:       LD    HL,(adrs)    ; nz= nic
               LD    A,(HL)
               INC   HL           ; z  HL=adrs=next za add hl,xx
               CP    "l"          ;    DE= operand add
               RET   NZ
               LD    A,(HL)
               INC   HL
               CP    "d"
               RET   NZ
               INC   HL
               INC   HL
               INC   HL
               INC   HL
               LD    E,L
               LD    D,H
               LD    A,14
               CP    (HL)
               INC   HL
               JR    C,$-2
               LD    A,(HL)
               INC   HL
               CP    "a"
               RET   NZ
               LD    A,(HL)
               INC   HL
               CP    "d"
               RET   NZ
               LD    BC,8
               ADD   HL,BC
               LD    (adrs),HL
               XOR   A
               RET

second:        LD    A,(HL)
               CP    " "
               JR    Z,second1
               CP    "a"
               JR    Z,second1
               CP    "p"
               RET   NZ

second1:       PUSH  IX
               PUSH  HL
               LD    IX,optimal

second2:       PUSH  HL
               LD    E,(IX+0)
               LD    D,(IX+1)
               LD    A,D
               OR    E
               JR    Z,endopt    ; koniec tabulky

               INC   IX
               INC   IX
               INC   IX
               INC   IX
               CALL  streq
               POP   HL
               JR    Z,second2

               LD    E,A
               LD    D,0
               ADD   HL,DE
               PUSH  HL
               LD    L,(IX-2)
               LD    H,(IX-1)
               CALL  jphl
               POP   HL
               POP   DE
               POP   IX
               EX    AF,AF'
               INC   A
               EX    AF,AF'
               RET

endopt:        POP   HL
               POP   HL
               POP   IX
               RET

               RET

CCDSGI:        CALL  outcall
               DM    "call CCDSGI"
               DB    13
               RET

CCDDGI:        CALL  outcall
               DM    "call CCDDGI"
               DB    13
               RET

CCINCI:        CALL  outcall
               DM    "call CCINCI"
               DB    13
               RET

CCDECI:        CALL  outcall
               DM    "call CCDECI"
               DB    13
               RET

CDPDPI:        CALL  outcall
               DM    "call CDPDPI"
               DB    13
               RET

CDPDPC:        CALL  outcall
               DM    "call CDPDPC"
               DB    13
               RET

CCPDPI:        CALL  outcall
               DM    "call CCPDPI"
               DB    13
               RET

decx:          LD    HL,pe15
               LD    DE,pe150
               JR    incx+6

decy:          LD    HL,pe16
               LD    DE,pe160
               JR    incx+6

incy:          LD    HL,pe14
               LD    DE,pe140
               JR    incx+6

incx:          LD    HL,pe13
               LD    DE,pe130
               PUSH  DE
               CALL  OUTBUF
               CALL  OUTBUF
               POP   HL
               JP    OUTBUF

outcall:       EX    (SP),HL
               CALL  OUTBUF
               EX    (SP),HL
               RET

pp1:           LD    HL,mov42
               CALL  OUTBUF
               JP    OUTBUF

pp2:           LD    HL,mov43
               CALL  OUTBUF
               JP    OUTBUF

pp3:           LD    (wds),HL
               LD    HL,mov44
               CALL  OUTBUF
               PUSH  HL
               DB    205
wds:           DW    0
               POP   HL
               JP    OUTBUF

mov42:         DM    "pop hl"
               DB    13
               DM    "push hl"
               DB    13
mov43:         DM    "pop de"
               DB    13
               DM    "push de"
               DB    13
mov44:         DM    "pop bc"
               DB    13
               DM    "push bc"
               DB    13

OUTBUF:        LD    A,(HL)     ; hl=stage bufer
               AND   A
               RET   Z

               LD    DE,BUFER
WHIL1:         LD    A,(HL)
               CP    13
               JR    Z,WHILE
               LDI
               JR    WHIL1

WHILE:         XOR   A
               LD    (DE),A
               INC   E
               JR    NZ,$-2

full:          INC   HL
               PUSH  HL
               LD    HL,(linesd)
               INC   HL
               LD    (linesd),HL

               LD    A,(BUFER)
               CP    "p"
               JR    Z,may
               CP    "e"
               JR    Z,may
               CP    "c"
               JR    Z,may3
               CP    " "
               JR    NZ,mayx

may:           LD    HL,optb
               CP    "p"
               JR    NZ,may1
               LD    HL,optp
may1:          CALL  fopt
               JR    NZ,mayx+3
               LD    A,(HL)
               INC   HL
               OR    (HL)
               DEC   HL
               JR    NZ,may1
               JR    mayx

may3:          LD    DE,mov8
               LD    HL,BUFER
               CALL  streq
               JR    Z,mayx
               LD    A,&89
               LD    (BUFER+66),A
               LD    DE,BUFER+67
               LD    A,(HL)
               CP    "!"
               JR    C,$+6
               LDI
               JR    $-7
               EX    DE,HL
               LD    (HL),0
               EX    DE,HL
               LD    DE,BUFER+2
               AND   A
               SBC   HL,DE
               LD    A,L
               LD    (BUFER+65),A
               JR    mayx+3

mayx:          CALL  TOKENIZUJ
               CALL  OUTPUT
               POP   HL
               XOR   A
               INC   A
               RET

fopt:          LD    E,(HL)
               INC   HL
               LD    D,(HL)
               INC   HL
               LD    C,(HL)
               INC   HL
               LD    B,(HL)
               INC   HL
               PUSH  HL
               PUSH  BC
               LD    HL,BUFER
               CALL  streq
               POP   DE
               POP   HL
               RET   Z
               EX    DE,HL
               LD    DE,BUFER+65
               LD    C,(HL)
               LD    B,0
               LDIR
               RET

TOKENIZUJ:     LD    HL,BUFER
               LD    DE,BUFER+66
               CALL  LEA60
               PUSH  HL
               LD    B,&0F
               LD    A,(HL)
               CALL  LEA91
               JR    NC,LE416
               INC   L
               DEC   B
LE3F9:         LD    A,(HL)
               CALL  LEA67
               JR    C,LE413
               CP    &3A
               JR    NZ,LE416
               LD    A,&0F
               SUB   B
               JR    Z,LE416
               POP   HL
               LD    (DE),A
               INC   E
               LD    B,&00
               LD    C,A
               LDIR
               INC   L
               JR    LE417

LE413:         INC   L
               DJNZ  LE3F9
LE416:         POP   HL
LE417:         CALL  LE4B2
               PUSH  DE
               LD    B,&80
               LD    DE,TOKENY
LE420:         PUSH  HL
LE421:         LD    C,(HL)
               RES   5,C
               LD    A,(DE)
               AND   &7F
               CP    C
               JR    NZ,LE43E
               LD    A,(DE)
               INC   DE
               INC   L
               RLA
               JR    NC,LE421
               DEC   DE
               LD    A,(HL)
               CALL  LEA67
               JR    C,LE43E
               POP   DE
               POP   DE
LE439:         LD    A,B
               LD    (DE),A
               INC   E
               JR    LE417
LE43E:         POP   HL
               JR    NC,LE449
LE441:         LD    A,(DE)
               INC   DE
               RLA
               JR    NC,LE441
               INC   B
               JR    LE420
LE449:         POP   DE
               LD    A,(HL)
               AND   &DF
               CP    &44
               JR    NZ,LE473
               INC   L
               LD    A,(HL)
               AND   &DF
               LD    B,&95
               CP    &42
               JR    Z,LE46A
               INC   B
               CP    &4D
               JR    Z,LE46A
               INC   B
               CP    &53
               JR    Z,LE46A
               INC   B
               CP    &57
               JR    NZ,LE472
LE46A:         INC   L
               LD    A,(HL)
               CALL  LEA67
               JR    NC,LE439
               DEC   L
LE472:         DEC   L
LE473:         LD    A,(HL)
LE474:         LD    (DE),A
               INC   L
               INC   E
               CP    &28
               JR    Z,LE417
               CP    &2C
               JR    Z,LE417
               CP    &26
               JR    NZ,LE498
LE483:         LD    A,(HL)
               CP    &20
               JR    Z,LE495
               CALL  LEA8A
               JR    NC,LE498
               CP    &5B
               JR    C,LE493
               AND   &DF
LE493:         LD    (DE),A
               INC   E
LE495:         INC   L
               JR    LE483
LE498:         CP    &22
               JR    NZ,LE4A7
LE49C:         LD    A,(HL)
               AND   A
               JR    Z,LE4AD
               LD    (DE),A
               INC   E
               INC   L
               CP    &22
               JR    NZ,LE49C
LE4A7:         LD    A,(HL)
               CP    &20
               JP    Z,LE417
LE4AD:         CALL  LE4B5
               JR    LE474
LE4B2:         CALL  LEA60
LE4B5:         LD    A,(HL)
               AND   A
               JR    NZ,LE4C3

LE4B9:         LD    (DE),A
               LD    A,E
               SUB   &C0
               LD    (BUFER+65),A
               POP   HL
               XOR   A
               RET

LE4C3:         CP    &3B
               RET   NZ
               LD    B,&01
               LD    (DE),A
               INC   E
LE4CA:         DEC   L
               BIT   7,L
               JR    Z,LE4D7
               LD    A,(HL)
               CP    &20
               JR    NZ,LE4D7
               INC   B
               JR    LE4CA

LE4D7:         LD    A,L
               ADD   A,B
               LD    L,A
               LD    A,B
LE4DB:         LD    (DE),A
               INC   L
               INC   E
               LD    A,(HL)
               AND   A
               JR    NZ,LE4DB
               JR    LE4B9
LEA60:         LD    A,(HL)
               CP    &20
               RET   NZ
               INC   L
               JR    LEA60

LEA67:         CALL  LEA8A
               RET   C
               CP    &21
               CCF
               RET   NC
               CP    &22
               RET   C
               RET   Z
               CP    &24
               RET   C
               CP    &2E
               CCF
               RET   NC
               RET   Z
               CP    &2F
               RET   Z
               CP    &3C
               CCF
               RET   NC
               CP    &41
               RET   C
               CP    &5C
               RET   Z
               SCF
               RET

LEA8A:         CP    &30
               CCF
               RET   NC
               CP    &3A
               RET   C
LEA91:         CP    &41
               CCF
               RET   NC
               CP    &5B
               RET   C
               CP    "_"    ; "_" OK
               SCF
               RET   Z
               CP    &61
               CCF
               RET   NC
               CP    &7B
               RET

LEA9F:         PUSH  HL
               LD    B,&FF
LEAA2:         LD    A,(HL)
               INC   L
               INC   B
               CP    &20
               JR    Z,LEAAC
               AND   A
               JR    NZ,LEAA2
LEAAC:         POP   HL
               RET

TOKENY:        DB    &C1,"A","D",&C3,"A","D",&C4,"A"
               DB    &C6,"A","N",&C4,&C2,"B",&C3,"B","I",&D4
               DB    &C3,"C","A","L",&CC,"C","C",&C6,"C",&D0
               DB    "C","P",&C4,"C","P","D",&D2,"C","P",&C9
               DB    "C","P","I",&D2,"C","P",&CC,&C4,"D","A"
               DB    &C1,"D",&C5,"D","E",&C3,"D","E","F",&C2
               DB    "D","E","F",&CD,"D","E","F",&D3,"D","E"
               DB    "F",&D7,"D",&C9,"D","J","N",&DA,"D","U"
               DB    "M",&D0,&C5,"E",&C9,"E","Q",&D5,"E",&D8
               DB    "E","X",&D8,&C8,"H","A","L",&D4,"H",&CC
               DB    &C9,"I",&CD,"I",&CE,"I","N",&C3,"I","N"
               DB    &C4,"I","N","D",&D2,"I","N",&C9,"I","N"
               DB    "I",&D2,"I",&D8,"I",&D9,"J",&D0,"J",&D2
               DB    &CC,"L",&C4,"L","D",&C4,"L","D","D",&D2
               DB    "L","D",&C9,"L","D","I",&D2,"L","I","S"
               DB    &D4,&CD,"M","D","A",&D4,"N",&C3,"N","E"
               DB    &C7,"N","O",&D0,"N",&DA,"O","F",&C6,"O"
               DB    &CE,"O",&D2,"O","R",&C7,"O","T","D",&D2
               DB    "O","T","I",&D2,"O","U",&D4,"O","U","T"
               DB    &C4,"O","U","T",&C9,&D0,"P",&C5,"P",&CF
               DB    "P","O",&D0,"P","U","S",&C8,&D2,"R","E"
               DB    &D3,"R","E",&D4,"R","E","T",&C9,"R","E"
               DB    "T",&CE,"R",&CC,"R","L",&C1,"R","L",&C3
               DB    "R","L","C",&C1,"R","L",&C4,"R",&D2,"R"
               DB    "R",&C1,"R","R",&C3,"R","R","C",&C1,"R"
               DB    "R",&C4,"R","S",&D4,"S","B",&C3,"S","C"
               DB    &C6,"S","E",&D4,"S","L",&C1,"S","L",&CC
               DB    "S",&D0,"S","R",&C1,"S","R",&CC,"S","U"
               DB    &C2,"X","O",&D2,&DA,&FF

OUTPUT:        LD    A,&F7
               IN    A,(&F9)
               AND   32
               JP    Z,abort
               IN    A,(251)
               PUSH  AF
               LD    A,(destiny)
               OUT   (251),A
               LD    HL,BUFER+65
               PUSH  IY
               POP   DE

               LD    B,0
               LD    C,(HL)
               LDIR

               BIT   6,D
               JR    Z,OKPI
               RES   6,D
               IN    A,(251)
               INC   A
               OUT   (251),A
               LD    (destiny),A

OKPI:          PUSH  DE
               POP   IY
               LD    (IY+0),0
               LD    B,A
               POP   AF
               OUT   (251),A
               LD    A,(file.page)
               DEC   A
               CP    B
               RET   NZ
               LD    A,D
               CP    &BF
               RET   C

               LD    (destiny+1),IY
               CALL  error
               DM    "out of workspace"
               NOP
               JP    abort
CCOR:
               LD    A,L
               OR    E
               LD    L,A
               LD    A,H
               OR    D
               LD    H,A
               RET
CCXOR:
               LD    A,L
               XOR   E
               LD    L,A
               LD    A,H
               XOR   D
               LD    H,A
               RET
CCAND:
               LD    A,L
               AND   E
               LD    L,A
               LD    A,H
               AND   D
               LD    H,A
               RET
CCEQ:
               CALL  CCCMP
               RET   Z
               DEC   HL
               RET
CCNE:
               CALL  CCCMP
               RET   NZ
               DEC   HL
               RET
CCGT:
               EX    DE,HL
               CALL  CCCMP
               RET   C
               DEC   HL
               RET
CCLE:
               CALL  CCCMP
               RET   Z
               RET   C
               DEC   HL
               RET
CCGE:
               CALL  CCCMP
               RET   NC
               DEC   HL
               RET
CCLT:
               CALL  CCCMP
               RET   C
               DEC   HL
               RET

CCCMP:
               LD    A,H
               XOR   &80
               LD    H,A
               LD    A,D
               XOR   128
               CP    H
               JP    NZ,CCCMP1
               LD    A,E
               CP    L
CCCMP1:        LD    HL,1
               RET
CCUGE:
               CALL  CCUCMP
               RET   NC
               DEC   HL
               RET
CCULT:
               CALL  CCUCMP
               RET   C
               DEC   HL
               RET
CCUGT:
               EX    DE,HL
               CALL  CCUCMP
               RET   C
               DEC   HL
               RET
CCULE:
               CALL  CCUCMP
               RET   Z
               RET   C
               DEC   HL
               RET
CCUCMP:
               LD    A,D
               CP    H
               JP    NZ,CCUCP1
               LD    A,E
               CP    L
CCUCP1:        LD    HL,1
               RET
CCASR:
               EX    DE,HL
               DEC   E
               RET   M
               LD    A,H
               RLA
               LD    A,H
               RRA
               LD    H,A
               LD    A,L
               RRA
               LD    L,A
               JP    CCASR+1
CCASL:
               EX    DE,HL
               DEC   E
               RET   M
               ADD   HL,HL
               JP    CCASL+1
CCSUB:
               AND   A
               EX    DE,HL
               SBC   HL,DE
               RET

CCNEG:         DEC   HL

CCCOM:         LD    A,H
               CPL
               LD    H,A
               LD    A,L
               CPL
               LD    L,A
               RET

CCLNEG:
               LD    A,H
               OR    L
               JP    NZ,$+4
               INC   L
               RET

               LD    HL,0
               RET

CCMUL:         EX    DE,HL
               LD    A,H
               XOR   D
               PUSH  AF
               XOR   H
               CALL  M,L6337
               LD    A,H
               OR    A
               CALL  M,CCNEG
               CALL  CCUMUL
               POP   AF
               RET   P
               JR    CCNEG

CCUMUL:        PUSH  BC
               LD    B,&10
               LD    A,H
               LD    C,L
               LD    HL,&0000
L6314:         ADD   HL,HL
               JR    C,L6321
               RL    C
               RLA
               JR    NC,L631F
               ADD   HL,DE
               JR    C,L6321
L631F:         DJNZ  L6314
L6321:         POP   BC
               RET

dive:          CALL  error
               DM    "division by zero"
               NOP
               LD    HL,0
               RET

CCDIV:         EX    DE,HL
               LD    A,D
               OR    E
               JR    Z,dive
               LD    A,H
               XOR   D
               PUSH  AF
               XOR   H
               CALL  M,L6337
               LD    A,H
               OR    A
               CALL  M,CCNEG
               CALL  CCUDIV
               POP   AF
               RET   P
               CALL  CCNEG
L6337:         EX    DE,HL
               CALL  CCNEG
               EX    DE,HL
               RET

CCUDIV:        PUSH  BC
               LD    B,D
               LD    C,E
               LD    DE,&0000
               LD    A,&10
L6345:         ADD   HL,HL
               JR    C,L634E
               DEC   A
               JR    NZ,L6345
               POP   BC
               RET

L634D:         ADD   HL,HL
L634E:         PUSH  AF
               RL    E
               RL    D
               LD    A,E
               SUB   C
               LD    A,D
               SBC   A,B
               JP    M,L635F
               LD    D,A
               LD    A,E
               SUB   C
               LD    E,A
               INC   L
L635F:         POP   AF
               DEC   A
               JR    NZ,L634D
               POP   BC
               RET

pe0:           DM    "ld hl,0"
               DB    13
               DM    " add hl,sp"
               DB    13
x99:           DM    "call CCGINT"
               DB    13,0

pe1:           DM    "ld hl,2"
               DB    13
pe2:           DM    " add hl,sp"
               DB    13
               DM    "call CCGINT"
               DB    13,0

pe3:           DM    "add hl,de"
               DB    13
               DM    "call CCGINT"
               DB    13,0

pe6:           DM    " add hl,sp"
               DB    13
               DM    "ld d,h"
               DB    13
               DM    "ld e,l"
               DB    13
               DM    "call CCGINT"
               DB    13
               DM    "inc hl"
               DB    13
x98:           DM    "call CCPINT"
               DB    13,0

pe7:           DM    " add hl,sp"
               DB    13
               DM    "ld d,h"
               DB    13
               DM    "ld e,l"
               DB    13
               DM    "call CCGINT"
               DB    13
               DM    "dec hl"
               DB    13
               DM    "call CCPINT"
               DB    13,0

pe10:          DM    "add hl,de"
               DB    13
               DM    "pop de"
               DB    13
               DM    "call CCPINT"
               DB    13,0

pe11:          DM    "add hl,de"
               DB    13
               DM    "pop de"
               DB    13
               DM    "ld a,l"
               DB    13
               DM    "ld (de),a"
               DB    13,0

pe12:          DM    "pop de"
               DB    13
               DM    "call CCPINT"
               DB    13,0

pe13:          DM    "push ix"
               DB    13
               DM    "pop hl"
               DB    13
               DM    "push hl "
               DB    13
               DM    "inc hl"
               DB    13
               DM    "push hl"
               DB    13
               DM    "pop ix"
               DB    13
               DM    "pop hl"
               DB    13,0

pe130:         DM    "inc ix"
               DB    13
pe140:         DM    "inc iy"
               DB    13
pe150:         DM    "dec ix"
               DB    13
pe160:         DM    "dec iy"
               DB    13

pe14:          DM    "push iy"
               DB    13
               DM    "pop hl"
               DB    13
               DM    "push hl "
               DB    13
               DM    "inc hl"
               DB    13
               DM    "push hl"
               DB    13
               DM    "pop iy"
               DB    13
               DM    "pop hl"
               DB    13,0

pe15:          DM    "push ix"
               DB    13
               DM    "pop hl"
               DB    13
               DM    "push hl "
               DB    13
               DM    "dec hl"
               DB    13
               DM    "push hl"
               DB    13
               DM    "pop ix"
               DB    13
               DM    "pop hl"
               DB    13,0

pe16:          DM    "push iy"
               DB    13
               DM    "pop hl"
               DB    13
               DM    "push hl "
               DB    13
               DM    "dec hl"
               DB    13
               DM    "push hl"
               DB    13
               DM    "pop iy"
               DB    13
               DM    "pop hl"
               DB    13,0

lda:           DM    "ld a,("
               DB    0
lda1:          DM    "ld hl,("
               DB    0
sta:           DM    "ld ("
               DB    0
sta2:          DM    "),a"
               DB    0
sta3:          DM    "),hl"
               DB    0
sta1:          DM    "ld a,l"
               DB    0

mov0:          DM    "ld a,l"
               NOP
               DM    "ld (de),a"
               NOP
mov1:          DM    "ld d,h"
               NOP
               DM    "ld e,l"
               NOP
mov2:          DM    "ex de,hl"
               NOP
mov3:          DM    "ld hl,"
               NOP
mov4:          DM    "ld de,"
               NOP
mov5:          DM    "push hl "
               NOP
mov6:          DM    "pop de"
               NOP
mov8:          DM    "call "
               NOP
mov9:          DM    "ret"
               NOP
mov10:         DM    "jp "
               NOP
mov11:         DM    "ld a,h"
               NOP
mov111:        DM    "or l"
               NOP
mov121:        DM    "jp z,"
               NOP
mov12:         DM    "db "
               NOP
               DM    "dw "
               NOP
               DM    "ds "
               NOP
mov13:         DM    "dw $+2"
               NOP
mov14:         DM    "add hl,hl"
               NOP
mov15:         DM    "add hl,de"
               NOP
mov16:         DM    "and a"
               NOP
mov7:          DM    "ex de,hl"
               NOP
               DM    "sbc hl,de"
               NOP
mov17:         DM    "inc hl"
               NOP
mov18:         DM    "dec hl"
               NOP
mov19:         DM    "ld a,h"
               NOP
               DM    "or l"
               NOP
mov131:        DM    "jp nz,"
               NOP
mov20:         DM    "xor a"
               NOP
               DM    "or h"
               NOP
mov141:        DM    "jp z,"
               NOP
mov21:         DM    "xor a"
               NOP
               DM    "or h"
               NOP
               DM    "jp m,"
               NOP
mov22:         DM    "pop hl"
               NOP
               DM    "push hl"
               NOP
mov23:         DM    "pop de"
               NOP
mov231:        DM    "push de"
               NOP
mov24:         DM    "pop bc"
               NOP
mov25:         DM    "push bc"
               NOP
mov26:         DM    "inc sp"
               NOP
mov27:         DM    "dec sp"
               NOP
mov28:         DM    " add hl,sp"
               NOP
mov29:         DM    "ld sp,hl"
               NOP
mov30:         DB    "l","d"," ","a",",",0

mov311:        DM    "ld l,(hl)"
               NOP
mov31:         DB    "l","d"," ","h",",","0",0

mov32:         DB    "e","x","x",0

mov40:         DM    "ld bc,"
               NOP
mov41:         DM    "add hl,bc"
               NOP
ccgchar:       DM    "ld l,(hl)"
               NOP
               DM    "rlca"
               NOP
               DM    "sbc a"
               NOP
               DM    "ld h,a"
               NOP

ccpint:        DM    "ld a,l"
               NOP
               DM    "ld (de),a"
               NOP
               DM    "inc de"
               NOP
               DM    "ld a,h"
               NOP
               DM    "ld (de),a"
               NOP

ccgint:        DM    "ld a,(hl)"
               NOP
               DM    "inc hl"
               NOP
               DM    "ld h,(hl)"
               NOP
mov31x:        DM    "ld l,a"
               NOP

nopt:          DB    "n","o","p",0

loadiy:        DM    "push iy"
               NOP
               DM    "pop hl"
               NOP
saveiy:        DM    "push hl"
               NOP
               DM    "pop iy"
               NOP

loadix:        DM    "push ix"
               NOP
               DM    "pop hl"
               NOP
saveix:        DM    "push hl"
               NOP
               DM    "pop ix"
               NOP

mains:         DB    "m","a","i","n",0

noccargc:      DM    "NOCCARGC"
               NOP

ccjmp:         DM    "ld (CCJUMP+1),hl"
               NOP

equs:          DM    "equ "
               NOP

t1:            DM    "di"
               DB    13
               DM    "push af"
               DB    13
               DM    "push bc"
               DB    13
               DM    "push de"
               DB    13
               DM    "push hl"
               DB    13
t3:            DM    "push ix"
               DB    13
               DM    "push iy"
               DB    13
               DM    "exx"
               DB    13
               DM    "ex af,af'"
               DB    13
               DM    "push af"
               DB    13
t111:          DM    "push bc"
               DB    13
               DM    "push de"
               DB    13
t11:           DM    "push hl"
               DB    13,0

t2:            DM    "pop hl"
               DB    13
               DM    "pop de"
               DB    13
t22:           DM    "pop bc"
               DB    13
               DM    "pop af"
               DB    13
               DM    "ex af,af'"
               DB    13
               DM    "exx"
               DB    13
t4:            DM    "pop iy"
               DB    13
t44:           DM    "pop ix"
               DB    13
               DM    "pop hl"
               DB    13
               DM    "pop de"
               DB    13
               DM    "pop bc"
               DB    13
               DM    "pop af"
               DB    13
               DM    "ei"
               DB    13
               DM    "reti"
               DB    13,0

svprolog:      DM    "org &4A00"
               DB    13
               DM    "dump &CA00"
               DB    13
               DM    "jp CCINIT"
               DB    13

prolog:        DM    ";              The SAM C prolog"
               DB    13,";",13
               DM    ";"
               DB    13

               DM    "org "
               NOP

pro1:          DM    "dump $"
               DB    13

pro3:          DM    "jp CCINIT"
               DB    13
               DM    "jp CCINIT+1"
               DB    13
pro5:          DM    "PROGNAME: dm "
me2DS                8
pro4:          DM    "STACK_:equ "
CINIT: inc "

here's starts your code"
sionDM               "SAM_VISION"
0
MEMAX

